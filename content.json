{"pages":[{"title":"关于我","text":"学生生涯毕业与浙江农林大学工业设计专业 工作实习的时候是在一个家具公司，后面觉得不适合做设计。遂辞职在家自学前端四个月。 2017-02-14 ~ 2018-03-30 金华快服杭州分公司 任职前端组长，获得优秀员工 2018-04-02 ~ 至今 获得 2018 年优秀员工、最佳敬业奖、2019 年成长之星 生活生活很单调，比较节约。","link":"/blog/about/index.html"}],"posts":[{"title":"原生js实现拾色器插件","text":"前言插件功能只满足我司业务需求，如果希望有更多功能的，可在下方留言，我尽量扩展！如果你有需要或者喜欢的话，可以给我 github 来个 star ? 仓库地址 在线预览 预览 准备首先在页面中引入 js 文件 在页面中写上如下代码: 123456789Colorpicker.create({ bindClass:'picker', // 这里的picker可随意填 不需要跟我一样 change: function(elem,hex){ // elem: 绑定的元素 // hex：当前选中颜色的hex值 elem.style.backgroundColor = hex; }}) bindClass:参数填入你要绑定拾色器的元素，页面中 class 为 picker 有几个，拾色器将会生成几个。拾色器将会分别绑定每个元素。点击每个元素时，都会自动打开该元素绑定的拾色器。 change:在选择的色彩改变的时候会触发该回调方法。会回传两个参数，第一个elem就是该拾色器生成时绑定的picker;第二个参数，hex 代表是回传的颜色值。起初是插件直接改变绑定元素的颜色，但是想到有些拾色器插件是绑定 input 表单，改变表单颜色值，有些是改变绑定元素的颜色。所以为了让使用者自由度更高点，暂提供两个回调参数让你自定义。如上面 我是直接改变元素颜色。 如果需要更多回调方法，我会尽量扩展 结尾如有什么功能需要增加的，可在评论区留言，我尽量满足。如有什么疏忽或错误，希望您指出。我会尽早修改，以免误导他人。","link":"/blog/2018/03/11/%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0%E6%8B%BE%E8%89%B2%E5%99%A8%E6%8F%92%E4%BB%B6/"},{"title":"原生js实现日期选择器插件","text":"前言距离自己上次写插件差不多半年了。公司技术栈都是用框架，调解下口味就写了此原生插件。前段时间在看 vue 源码受了点启发，本插件有点接近数据驱动视图更新的响应式渲染。如果希望有更多功能的，可在下方留言，我尽量扩展！如果你有需要或者喜欢的话，可以给我 github 来个 star 😆 仓库地址 在线预览 预览 准备首先在页面中引入 css、js 文件(文件在我的 github，如何引入可看 github 示例 html) 在页面中写上如下代码: 12345678910Calendar.create({ classN: 'calendar-item', // 这里的calendar-item可随意填 不需要跟我一样 callBack: function(bindElem, dateObj) { // bindElem: 该控件绑定的元素 // dateObj: 选中的年、月、日 如： {year: 2018, month: 8, date: 12} // 用户可通过bindElem和dateObj搞事情啦 😆 bindElem.innerHTML = dateObj.year + '-' + dateObj.month + '-' + dateObj.date; }}) String: classN:参数填入你要绑定日期控件的元素。本插件初始化的时候，会根据用户提供的classN类名生成相应个数 Function: callBack:bindElem: 该控件绑定的元素,dateObj: 选中的年、月、日 如： {year: 2018, month: 8, date: 12}。通过返回参数，让用户在回调函数中通过回调参数做操作，给用户更高的自由度。如果需要更多回调方法，我会尽量扩展 结尾如有什么功能需要增加的，可在评论区留言，我尽量满足。如有什么疏忽或错误，希望您指出。我会尽早修改，以免误导他人。","link":"/blog/2018/08/12/%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8%E6%8F%92%E4%BB%B6/"},{"title":"原生js实现拖拽缩放预览图片插件","text":"前言插件功能暂只满足我司业务需求，如果希望有更多的功能，可在下方留言，我尽量扩展！如果你有需要或者喜欢的话，可以给我 github 来个 star ? 仓库地址 &gt; 在线预览 准备 引入 preview.js 文件 指定一个容器的 id，插件只预览该容器内的图片，举个栗子?： 1234567&lt;div id=\"wrap\"&gt; &lt;div&gt; &lt;img src=\"./data/girl1.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;img src=\"./data/girl2.jpg\" alt=\"\" /&gt; &lt;img src=\"./data/girl3.jpg\" alt=\"\" /&gt;&lt;/div&gt; 其中 id 为 wrap 的 div 就是 2 中所指的容器。插件只预览该容器下的所有图片。 123var preview = new Preview({ imgWrap: 'wrap' // 指定该容器里的图片点击预览}) imgWrap 键的值就是容器的 id 如果觉得样式不满意什么的，可以直接 css 覆盖就可以了。 预览 总结如有疏忽或错误，希望您及时指出，我会尽早修改?。有什么需要交流的可在评论区与我交流","link":"/blog/2018/02/13/%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD%E7%BC%A9%E6%94%BE%E9%A2%84%E8%A7%88%E5%9B%BE%E7%89%87%E6%8F%92%E4%BB%B6/"},{"title":"nodejs实现formdata上传文件","text":"1.关于 formdata XMLHttpRequest Level 2 添加了一个新的接口——FormData。利用 FormData 对象，我们可以通过 JavaScript 用一些键值对来模拟一系列表单控件，我们还可以使用 XMLHttpRequest 的 send() 方法来异步的提交表单。与普通的 Ajax 相比，使用 FormData 的最大优点就是我们可以异步上传二进制文件。FormData 的 api 方法一创建一个空 FormData 对象：var formData = new FormData()使用 FormData.append 添加一个键/值对：formData.append('username', 'Chris'); 方法二：利用 form 表单传递给 formdata123456789101112131415&lt;form id=\"myForm\" name=\"myForm\"&gt; &lt;div&gt; &lt;label for=\"username\"&gt;Enter name:&lt;/label&gt; &lt;input type=\"text\" id=\"username\" name=\"username\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"useracc\"&gt;Enter account number:&lt;/label&gt; &lt;input type=\"text\" id=\"useracc\" name=\"useracc\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"userfile\"&gt;Upload file:&lt;/label&gt; &lt;input type=\"file\" id=\"userfile\" name=\"userfile\" /&gt; &lt;/div&gt; &lt;input type=\"submit\" value=\"Submit!\" /&gt;&lt;/form&gt; 12var myForm = document.getElementById('myForm');formData = new FormData(myForm); 2.formdata 上传文件目录结构1234567.├── index.js├── node_modules├── package.json└── public ├── index.html └── uploads 客户端代码1234567891011121314151617181920212223242526&lt;!-- index.html --&gt;&lt;input id=\"file\" type=\"file\" /&gt;&lt;button id=\"btn\"&gt;点击上传&lt;/button&gt;&lt;img id=\"img\" src=\"\" alt=\"\" /&gt;&lt;script&gt; var btn = document.getElementById('btn'), file = document.getElementById('file'), img = document.getElementById('img'); btn.onclick = function() { // 获取文件 var upload_file = file.files[0], formdata = new FormData(), xhr = new XMLHttpRequest(); formdata.append('date', new Date().toLocaleString()); // 将文件添加到formdata对象中，（注：下面的file字段名在node中有用） formdata.append('file', upload_file); xhr.open('POST', '/upload', true); xhr.onreadystatechange = function() { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { img.src = xhr.responseText; } }; xhr.send(formdata); };&lt;/script&gt; 服务端代码123456789101112131415161718192021222324252627282930313233343536373839// index.jsvar express = require('express');var app = express();/* 1. 保存在文件夹中的文件为二进制，所以想在本地点开能预览的，取消下面fs模块引用的注释 2. 并在命令行中输入 npm install fs --save*/// var fs = require(\"fs\");var multer = require('multer');// 这里dest对应的值是你要将上传的文件存的文件夹var upload = multer({ dest: './public/uploads' });app.use(express.static('./public'));app.post('/upload', upload.single('file'), (req, res) =&gt; { // req.file 是 'file' 文件的信息 （前端传递的文件类型在req.file中获取） // req.body 将具有文本域数据，如果存在的话 。（上面前端代码中传递的date字段在req.body中获取） console.log(req.body); //{ date: '2018/1/20 下午5:25:56' } // ---------- 因为保存的文件为二进制，取消下面代码块注释可让保存的图片文件在本地文件夹中预览 ------ /* var file_type; if (req.file.mimetype.split('/')[0] == 'image') file_type = '.' + req.file.mimetype.split('/')[1]; if (file_type) { fs.rename(req.file.path, req.file.path + file_type, function (err, doc) { if (err) { console.error(err); return; } console.log('55'); res.send('./uploads/' + req.file.filename + file_type) }) return; } */ // --------------------- res.send('./uploads/' + req.file.filename);});app.listen(9999); 接下来解释下上述代码 上面的例子是上传图片，服务端传回图片路径进行展示。上传其他文件同理！ index.js 中依赖 express、multer 可以通过npm install express multer --save进行安装，当然你也可以不使用 express。接下去重点讲述下 multer： 1.安装：npm install --save multer 2.使用：multer(opts) Multer 接受一个 options 对象，其中最基本的是 dest 属性，这将告诉 Multer 将上传文件保存在哪。如果你省略 options 对象，这些文件将保存在内存中，永远不会写入磁盘。通常，只需要设置 dest 属性 像这样：var upload = multer({ dest: 'uploads/' }) // dest对应的值就是你想文件存储的文件夹single(fieldname)接受一个以 fieldname 命名的文件。这个文件的信息保存在 req.file。（这里的 fieldname 指的是 formdata.append(“file”,文件）中的’file’字段。其他方法详见multer 文档。 Multer 会添加一个 body 对象 以及 file 或 files 对象 到 express 的 request 对象中。body 对象包含表单的文本域信息，file 或 files 对象包含对象表单上传的文件信息。 123456app.post('/upload', upload.single('file'), (req, res) =&gt; { // req.file 是 'file' 文件的信息 （前端传递的文件类型在req.file中获取） // req.body 将具有文本域数据，如果存在的话 。（上面前端代码中传递的date字段在req.body中获取） console.log(req.body); // { date: '2018/1/20 下午5:25:56' } res.send('./uploads/' + req.file.filename);}); 注意事项一、formdata 在控制台打印为空 可通过下面方法获取： 1234567var formData = new FormData();formData.append('username', 'Chris');formData.append('username', 'Bob');// get()函数只会返回username附加的第一个值formData.get('username'); // Returns \"Chris\"// getAll()函数将返回username一个数组中的两个值：formData.getAll('username'); // Returns [\"Chris\", \"Bob\"] 更多 formdata 方法 二、如果 formdata 添加文件成功了的话，还是上传失败，可以看看头部是否为multipart/form-data 文章都是学习过程中的总结，如果发现错误，欢迎留言指出","link":"/blog/2018/01/20/node.js%E5%AE%9E%E7%8E%B0formdata%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"title":"原生js实现省市区三级联动插件","text":"前言插件功能只满足我司业务需求，如果希望有更多功能的，可在下方留言，我尽量扩展！如果你有需要或者喜欢的话，可以给我 github 来个 star ? 仓库地址 在线预览 准备12// 页面上先引入css与js文件&lt;div id=\"wrap\"&gt;&lt;/div&gt; 页面中的容器标签不限制，只需给个 id 就行 12345678910var address = new Address({ wrapId: 'wrap', showArr: ['provinces','citys','areas'], beforeCreat:function(){ console.log(\"beforeCreat\") }, afterCreat:function(){ console.log('afterCreat'); }}) wrapId:&quot;wrap&quot; // 此处的wrap就是上面容器的id showArr: ['provinces','citys','areas'] // 此处分别代表省、市、区容器的id 举个例子：如果传递的数组['provinces','citys','areas']长度为 3，那么将会出现省市区，数组中三个字符串分别是省、市、区容器的 id 如传递的数组['provinces','citys']长度为 2，那么将会出现省市，数组中的两个字符串分别是省、市容器的 id 如数组长度为 1 的时候就不说了 beforeCreat 插件开始创建前执行的回调函数 afterCreat 插件创建完成后执行的回调函数 预览 总结如有什么功能需要增加的，可在评论区留言，我尽量满足。如有什么疏忽或错误，希望您指出。我会尽早修改，以免误导他人。","link":"/blog/2018/02/12/%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0%E7%9C%81%E5%B8%82%E5%8C%BA%E4%B8%89%E7%BA%A7%E8%81%94%E5%8A%A8%E6%8F%92%E4%BB%B6/"},{"title":"思维导图—你不知道的JavaScript中卷","text":"xmind 地址 预览","link":"/blog/2018/08/14/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E2%80%94%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD%E5%8D%B7/"},{"title":"变量命名规范","text":"前言好的命名规范可以让你不用天天为取名字而苦恼、找 bug 时，更快的定位到 bug 在哪个位置 组件的命名和它的功能相配套 不与其他业务组件重名,让人一眼就区分 不一定要好听酷炫,但是实用.让开发者产生条件反射,看到命名就会想到这个组件的实用场景 易写易记,短小却精炼,不繁琐 BEM.nav 某一块展示/功能区域 (div).navitem 这块展示/功能区域（div）里面的某个元素，比如: navitem.navitem–hide/ .navitem–open 某个元素或者某个块的状态 不要加敏感词汇我曾经给一个元素取了个 class 为 advertisement，后来测试人员发现页面上这块元素不见了。后来发现 360 浏览器开启去广告模式，直接把这个 div 给删了。 函数的命名规范 拼写准确 比如我的 confirm 与 confrim 把函数未执行归咎于代码逻辑问题 使用正常的时态 特别是代码中状态的变量或者函数的命名，比如 onXxxxStarted 表示 xxx 已经启动了，isConnecting 表示正在连接。正确的时态可以给使用者传递准确的信息。 函数和属性的命名是有区别的 - 如果是函数，建议使用动宾结构动宾结构就是 doSomething，这样的函数命名含义明确比如： openFile, setName, addNumber… - 如果是属性命名，建议使用定语+名词比如 fileName, maxLength, textSize 不要单词+拼音混合使用比如：useJiFen，huKouNumber.. 缺乏美感不说，可读性大幅度降低。 谨慎使用缩写除非是约定俗成已经被广泛使用的缩写，否则老老实实用完整拼写。典型的反面例子: count-&gt;cnt, manager-&gt;mgr password-&gt;pwd button-&gt;btn 无论我们使用 eclipse 或者 intellij, 都有很好的自动完成功能，名字长一点没关系的，可读性更重要。 命名的语义话（动词、名词的区分）###Vue 组件命名 Ant.design 的 React 组件是下面这样的时候，我感觉到一种自由的味道。首先，组件名可以使用原生 HTML 标签名，意味着再也不用较劲脑汁去规避原生 HTML 标签了。另外，这些组件都使用了首字母大写标签名，使它们很容易地与原生小写的 HTML 标签区分。 12345678910111213ReactDOM.render( &lt;div&gt; &lt;Button type='primary'&gt;Primary&lt;/Button&gt; &lt;Input placeholder='Basic usage' /&gt; &lt;Select defaultValue='.com' style={{ width: 70 }}&gt; &lt;Option value='.com'&gt;.com&lt;/Option&gt; &lt;Option value='.jp'&gt;.jp&lt;/Option&gt; &lt;Option value='.cn'&gt;.cn&lt;/Option&gt; &lt;Option value='.org'&gt;.org&lt;/Option&gt; &lt;/Select&gt; &lt;/div&gt;, mountNode); 基础组件命名应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V。 12345678910**反例** components/ |- button.vue |- loading.vue |- slide.vue**正例** components/ |- BaseButton.vue |- BaseLoading.vue |- BaseSlide.vue 单个活跃实例的组件单个活跃实例的组件应该以 The 前缀命名,以示其唯一性这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。 12345678**反例** components/ |- SaleManage.vue |- ImportExcel.vue**正例** components/ |- TheSaleManage.vue |- TheImportExcel.vue 紧密耦合的组件名和父组件紧密耦合的子组件应该以父组件的命名为前缀.如果一个组件只在其父组件某个场景下有意义,这层关系应该体现在组件名上,因为编辑器通常按照首字母顺序组织文件. 12345678910**反例** components/ |- SearchBox.vue |- SearchItem.vue |- SearchButton.vue**正例** components/ |- SearchBox.vue |- SearchBoxItem.vue |- SearchBoxButton.vue 组件命中的单词顺序组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。 12345678910111213141516**反例** components/ |- ClearSearchButton.vue |- ExcludeFromSearchInput.vue |- LaunchOnStartupCheckbox.vue |- RunSearchButton.vue |- SearchInput.vue |- TermsCheckbox.vue**正例** components/ |- SearchButtonClear.vue |- SearchButtonRun.vue |- SearchInputQuery.vue |- SearchInputExcludeGlob.vue |- SettingsCheckboxTerms.vue |- SettingsCheckboxLaunchOnStartup.vue 完整单词的组件名编辑器中的自动补全已经相当友好,让书写长的组件名的代价已经可以微乎其微,同样的效率更易于理解,何乐而不为? 12345678**反例** components/ |- soManage.vue |- woManage.vue**正例** components/ |- SaleOrderManage.vue |- WorkOrderManage.vue prop 的大小写在声明时始终采用(camelCase),在模板和 JSX 中应该始终使用( kebab-case)。单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。 12345678910**反例**props: { 'greeting-text': String}&lt;WelcomeMessage greetingText=\"hi\"/&gt;**正例**props: { greetingText: String}&lt;WelcomeMessage greeting-text=\"hi\"/&gt; vue 中变量命名规范变量命名使用主要集中在 data 和 methods 中 data 中更多的是名词与状态布尔类型名词：名词太多，大致分为复数、后缀加 Arr、加 Obj 之类作为约定规则状态布尔型： 1.表示是不是，用 is+ ：如 isEmpty 表示有没有，用 has+… ： 如 hasClass 表示能不能，用 can+… ：如 canSubmit 单词本身的形式（过去式、进行时、将来时）：had 开头、ing、ed 结尾等 methods 中 handle+以下：dd/remove，添加/移除add/delete，添加/删除insert/delete，插入/删除start/stop，开始/停止begin/end，开始/结束send/receive，发送/接收get/set，取出/设置get/release，获取/释放put/get，放入/取出up/down，向上/向下show/hide，显示/隐藏open/close，打开/关闭increment/decrement，增加/减少lock/unlock，锁/解锁next/previous，下一个/前一个create/destroy，创建/销毁min/max，最小/最大visible/invisible，可见/不可见pop/push，出栈/入栈store/query，存储/查询 结合业务：表单提交：submit、send表单增删改查：add、delete、update、search、reset上传附件：upload关闭打开弹窗：open/close检查：check 参考链接CSS 命名方式=》BEM如何定义一个好的变量名理解 CSS 命名规范–BEM聊聊 Vue 组件命名那些事谈谈函数的命名规范vue 组件命名指南,不为取名而纠结","link":"/blog/2018/04/26/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"},{"title":"原生js实现移动端选择器插件","text":"前言插件功能只满足我司业务需求，如果希望有更多功能的，可在下方留言，我尽量扩展！如果你有需要或者喜欢的话，可以给我 github 来个 star ? 仓库地址 在线预览(记得将浏览器切换到手机模式) 预览 准备首先在页面中引入 css,js 文件 每次需要弹出该组件时通过 new 一个实例来生成，代码如下: 123456789101112131415var data = { 1:{ 2:[3,4] }}var pickerView = new PickerView({ bindElem: elem, // 绑定的元素,用于区别多个组件存在时回显区别，如果单个可以随意填某个元素 data: data, // 说明：该参数必须符合json格式 且最里层是个数组，如上面的data变量所展示的[3,4]。 title: '标题2', // 顶部标题文本 默认为“标题” leftText: '取消', // 头部左侧按钮文本 默认为‘取消’ rightText: '确定', // 头部右侧按钮文本 默认为“确定” rightFn: function( selectArr ){ // 点击头部右侧按钮的回调函数，参数为一个数组，数组对应滚轮中每项对应的值 }}); 字段介绍如上注释，滚轮的数量取决于你 json 嵌套的层数。如下： 1var data = [1, 2, 3]; 1234var data = { \"小明家\":[\"小明爸爸\",\"小明妈妈\",\"小明爷爷\",\"小明奶奶\",\"小明爸爸\",\"小明妈妈\",\"小明爷爷\",\"小明奶奶\"], \"小红家\":[\"小红爸爸\",\"小红妈妈\"]} 案例123&lt;!-- html --&gt;&lt;button style=\"font-size:50px;\" id=\"btn\"&gt;按钮&lt;/button&gt;&lt;div class=\"showText\"&gt;&lt;/div&gt; button 标签是用来每次点击的时候打开组件 div 标签用来展示选择的内容 1234567891011121314151617181920212223242526272829//js// var data = 地级市json数据，过大 就不展示了var data = { \"小明家\":{ \"小明爸爸\":[1,2,6,7,7,8,8,9,0,6,98,76,5], \"小明妈妈\":[3,4] }, \"小红家\":{ \"小红爸爸\":[5,6], \"小红妈妈\":[7,8] }}var btn = document.getElementById(\"btn\");btn.onclick = function(){ var pickerView = new PickerView({ bindElem: btn, data: data, title: '家庭', leftText: '取消', rightText: '确定', rightFn: function( selectArr ){ console.log(selectArr,'selectarr'); // 将家庭成员展示到showText类名的div中 document.querySelector(\".showText\").innerText = selectArr.join(\"-\"); } });} 说明： 每次显示组件的时候都需要 new 一个实例，如上 button 标签每次被点击的时候都 new 一个。效果如下： 结尾如有什么功能需要增加的，可在评论区留言，我尽量满足。如有什么疏忽或错误，希望您指出。我会尽早修改，以免误导他人。","link":"/blog/2018/02/25/%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%89%E6%8B%A9%E5%99%A8%E6%8F%92%E4%BB%B6/"},{"title":"思维导图—描述vue执行机制","text":"xmind 地址 参考（排序按照看过的时间顺序）剖析 Vue.js 内部运行机制Vue.js 技术揭秘Vue 源码阅读 - 文件结构与运行机制【大型干货】手拉手带你过一遍 vue 部分源码当面试官问你 Vue 响应式原理，你可以这么回答他Vue 源码剖析——render、patch、updata、vnode(这篇挺不错的)","link":"/blog/2018/08/02/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E2%80%94%E6%8F%8F%E8%BF%B0vue%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"},{"title":"基于react、socket.io、node.js仿微信开发","text":"前言这个项目是我自学 react+redux 的第一个项目，并结合自己之前所学的 node+mongodb，来模仿开发微信客户端。利用每天下班时间边学习边写。由于本人技术水平有限，比较适合新手。目前还没有写完。喜欢的话可以帮忙给我 github 点个 star ^_^ 项目地址https://github.com/zhouatie/wechat 技术栈react+redux+react-router4+socket.io+axios+node.js+mongodb 说明1234本地启动mongodb服务分别进入wechat跟server文件夹npm installwechat里npm run startserver里node app.js 和 chat.js 这两个文件 开发环境：macbook pro 、vscode、Chrome、node 如果 npm install 太慢导致有些 npm 依赖包下载失败 你可以看控制台的报错信息，再手动 npm install 具体的开发包，推荐使用淘宝的注册源，直接运行 npm install -g cnpm --registry=https://registry.npm.taobao.org 目标功能 [√] 注册 [√] 登录 [√] 添加好友 [√] 支持私聊 [√] 消息列表的展示 [√] 未读消息数量的显示 [√] axios 数据跨域的设置 群聊 [√] 上传头像 [√] 个人信息的编辑 朋友圈 部分截图 总结1.之前写 vue 项目的时候，在 main.js 文件中写 express 接口，就行了，就不存在跨域问题。在 create-react-app 启动的静态资源服务中，实在找不到哪里可以写接口，找了好久的 node_modules ，都不知道在哪里下手。好在 create-react-app 中的 package.json 中加上：proxy:http://localhost:4000就能解决跨域问题了。 2.在 app.js 页面中，使用的是 express 框架，写 socket.io 不知道为什么会提醒跨域问题，而我前面的登录接口用 axios 跨域就没有问题，而且我在 express 的头部做了 CORS 处理，还是存在跨域问题。所以只能另启了一个 node 服务，采用原生 node.js 编写，跨域就成功了。但是我在新写的服务中，换成用 express 框架，结果也提示了存在跨域问题。目前个人猜测 express 可能有什么跨域机制。 3.在引入 react-router4 的时候遇到了很多疑难杂症，晚上大部分的 react-router4 一下的版本。按照网上来做，好多报错，到处找博客找文章。后来通过 react-router 英文文档的阅读解决了各种报错问题。 4.我是通过 redux 来更新消息列表，中间出现 store 数据更新了，组件却不渲染。后来求助好友后，原来是我强制修改了 state 导致页面无法即使刷新。 5.formdata 上传文件，相当于表单上传，头部为Content-Type:multipart/form-data,这点要注意了！ 注意: Multer 不会处理任何非 multipart/form-data 类型的表单数据。具体见 multer 12345678910111213141516var multer = require('multer');var upload = multer({ dest: '../wechat/public/logos' }); // dest 指的是图片存到哪个文件夹里// 上传头像app.post('/uploadLogo', upload.single('avatar'), (req, res) =&gt; { User.update( { _id: req.body.id }, { $set: { logo: './logos/' + req.file.filename } }, function() { res.send({ status: 'success', url: './logos/' + req.file.filename }); } );}); 参考资料《深入浅出 React 和 Redux》– 程墨 《MongoDB 实战（第二版）》 react-router react redux 中文文档 mongoose 基于 Vue、Nodejs、Socket.io 的聊天应用 multer 文章都是学习过程中的总结，如果发现错误，欢迎留言指出","link":"/blog/2018/01/21/%E5%9F%BA%E4%BA%8Ereact%E3%80%81socket-io%E3%80%81node-js%E4%BB%BF%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"},{"title":"浏览器http缓存","text":"浏览器 http 缓存大致流程图 缓存好处 缓解服务器压力(不用每次去请求资源)； 提升性能(打开本地资源速度当然比请求回来再打开要快得多)； 减少带宽消耗(我相信你可以理解)； 缓存种类 浏览器缓存 浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。 代理服务器缓存 网关缓存 数据库缓存 通用首部字段cache-control缓存请求指令 指令 参数 说明 no-cahce 无 强制向源服务器再次验证 no-store 无 不缓存请求或响应的任何内容 max-age = [秒] 必需 期望在指定时间内的响应仍有效 max-state( = [秒]) 可省略 接收已过期的响应 min-fresh = [秒] 必需 期望在指定时间内发响应仍有效 no-transform 无 代理不可更改媒体类型 only-if-cached 无 从缓存获取资源 cache-extension - 新指令标记[token] ##### 缓存响应指令 指令 参数 说明 public 无 可向任意方提供响应的缓存 private 可省略 仅向特定用户返回响应 no-cahce 可省略 缓存前必需先确认其有效性 no-store 无 不缓存请求或响应的任何内容 no-transform 无 代理不可更改媒体类型 must-revalidate 无 可缓存但必须再想源服务器进行确认 proxy-revalidate 无 要求中间缓存服务器对缓存的响应有效性再进行确认 max-age = [秒] 必需 响应的最大Age值 s-maxage = [秒] 必需 公共缓存服务器响应的最大Age值 cache-extension - 新指令标记[token] 表示是否能缓存的指令public 指令 Cache-Control: public 当使用 public 指令时，则明确表明其他用户也可利用缓存。private 指令 Cache-Control: private 当使用 private 指令时，响应只以特定的用户作为对象，这与 public 指定的行为相反。 缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存 no-cache 指令 Cache-Control: no-cache 使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。 客户端发送的请求如果包含 no-cache 指令，则表示客户端将不会缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。 no-store 指令 Cache-Control: no-store 当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。因此，该指令规定缓存不能再本地存储请求或响应的任一部分。 s-maxage 指令 Cache-Control: s-maxage=604800 (单位 ：秒) s-maxage 指令的功能和 max-age 指令的相同，他们的不同点是 s-maxage 指令适用于供多位用户使用的公共缓存服务器。 max-age 指令 Cache-Control: max-age = 604800 (单位 ：秒) 当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器。当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而 HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略掉。 min-fresh 指令 Cache-Control: min-fresh=60(单位：秒) min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。比如，当指定 min-fresh 为 60 秒后，在这 60 秒以内如果有超过有效期限的资源都无法作为响应返回了。 max-stale 指令 Cache-Control:max-stale=3600(单位：秒） 使用 max-stale 可指示缓存资源，即使过期也照常接收。 如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指令中指定了具体数值，那么即使过期，只要扔处于 max-stale 指定的时间内，仍旧会被客户端接收。 only-if-cached 指令 Cache-Control: only-if-cached 使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码 504 Gateway Timeout。 must-revalidate 指令 Cache-Control: must-revalidate 使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。 若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条 504（Gateway Timeout）状态码。 另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已经在首部使用了 max-stale,也不会再有效果）。 proxy-revalidate 指令 Cache-Control: proxy-revalidate proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。 no-transform 指令 Cache-Control: no-transform 使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。 Cache-Control 扩展 cache-extension token Cache-Control: private, community=&quot;UCI&quot; 通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。 如上例，Cache-Control 首部字段本身没有 community 这个指令。借助 extension tokens 实现了该指令的添加。如果缓存服务器不能理解 community 这个新指令，就会直接忽略。因此，extension tokens 仅对能理解它的缓存服务器来说是有意义的。 Date首部字段 Date 表明创建 HTTP 报文的日期和时间。\bHTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式，如下示例。Date: Tue, 03 Jul 2012 04:40:59 GMT之前的 HTTP 协议版本中使用在 RFC850 中定义的格式，如下所示。Date: Tue, 03-Jul-12 04:40:59 GMT除此之外，还有一种格式。它与 C 标准库内的 asctime()函数的输出格式一致。Date: Tue Jul 03 04:40:59 2012 PragmaPragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。 \bPragma: no-cache 该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。 所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本中却是不现实的。因此，发送的请求会同时含有下面两个首部字段。 12Cache-Control: no-cachePragma: no-cache 请求首部字段If-Match/If-Modified-Since/If-None-Match/If-Range/If-Unmodified-Since 形如 If-xxx 这种形式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。 If-Match 只有当 If-Match 的值与服务器上实体的 Etag 值 \b 一致时，服务器才会接受请求。反之，则返回状态码 412 \bPrecondition Failed 的响应。 \bIf-Modified-Since 如果在 If-Modified-Since 字段指定的日期时间后，资源发生了更新，服务器会接受请求。比如请求首部If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT,而服务器上的Last-Modified: Sun 29 Aug 2004 14:03:05 GMT，因为是在 2004 年 4 月 15 日之后更新过的资源，所以服务器会接受请求。 If-None-Match 只有在 If-None-Match 的字段值与 Etag 值不一致时，可处理该请求。与 If-Match 首部字段的作用相反。 \bIf-Range If-Range HTTP 请求头字段用来使得 Range 头字段在一定条件下起作用：当字段值中的条件得到满足时，Range 头字段才会起作用，同时服务器回复 206 部分内容状态码，以及 Range 头字段请求的相应部分；如果字段值中的条件没有得到满足，服务器将会返回 200 OK 状态码，并返回完整的请求资源。 If-Unmodified-Since 首部字段If-Unmodified-Since和首部字段If-Modified-Since的作用相反。他的作用是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定的日期时间后发生了更新，则以状态码 412 \bPrecondition Faied 作为相应返回。 响应首部字段响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息、以及对客户端的附加要求等信息。 Age 首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。 若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。Age 消息头的值通常接近于 0。表示此消息对象刚刚从原始服务器获取不久；其他的值则是表示代理服务器当前的系统时间与此应答消息中的通用消息头 Date 的值之差。 Etag 首部字段 Etag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 Etag 值。 另外，当资源更新时，Etag 值也需要更新。生成 Etag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。 强 Etag 值：不论实体发生多么细微的变化都会改变其值。Etag: &quot;usagi-1234&quot; 弱 Etag 值：弱 Etag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 Etag 值。这时，会在字段值最开始处附加 W/。 Etag:W/&quot;usagi-1234&quot;。 实体首部字段\bExpiresExpires: Wed, 04 Jul 2012 08:26:05 GMT 首部字段Expires会将资源失效的日期告知客户端。缓存服务器在接受到含有首部字段Expires的响应后，会以缓存来应答请求，在Expires字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。 源服务器不希望缓存服务器对资源缓存时，最好在Expires字段内写入与首部字段 Date 相同的时间值。 但是，当首部字段Cache-Control有指定max-age指令时，比起首部字段Expires，\b 会优先处理 max-age 指令。 \bLast-ModifiedLast-Modified: Wed, 23 May 2012 09:59:55 GMT 首部字段Last-Modified指明资源最终修改时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。 参考与推荐《图解 HTTP》缓存详解浅谈 web 缓存浅谈浏览器缓存","link":"/blog/2018/08/26/%E6%B5%8F%E8%A7%88%E5%99%A8http%E7%BC%93%E5%AD%98/"},{"title":"vue响应式原理","text":"initState new Vue() =&gt; _init() =&gt; initState: 123456789101112131415function initState(vm: Component) { vm._watchers = []; const opts = vm.$options; if (opts.props) initProps(vm, opts.props); if (opts.methods) initMethods(vm, opts.methods); if (opts.data) { initData(vm); } else { observe((vm._data = {}), true /* asRootData */); } if (opts.computed) initComputed(vm, opts.computed); if (opts.watch &amp;&amp; opts.watch !== nativeWatch) { initWatch(vm, opts.watch); }} 判断该 vue 实例是否存在props、methods、data、computed、watch进行调用相应的初始化函数 initProps 与 initData主要工作是调用defineProperty给属性分别挂载 get(触发该钩子时，会将当前属性的 dep 实例推入当前的 Dep.target 也就是当前 watcher 的 deps 中即它订阅的依赖，Dep.target 下文会讲到。且该 dep 实例也会将当前 watcher 即观察者推入其 subs 数组中)、set 方法（通知该依赖 subs 中所有的观察者 watcher 去调用他们的 update 方法）。 initComputed它的作用是将 computed 对象中所有的属性遍历，并给该属性 new 一个 computed watcher（计算属性中定义了个 dep 依赖，给需要使用该计算属性的 watcher 订阅）。也会通过调用defineProperty给 computed 挂载 get（get 方法）、set 方法（set 方法会判断是否传入，如果没传入会设置成 noop 空函数）computed属性的 get 方法是下面函数的返回值函数 123456789function createComputedGetter(key) { return function computedGetter() { const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]; if (watcher) { watcher.depend(); return watcher.evaluate(); } };} 注意其中的watcher.depend(),该方法让用到该属性的 watcher 观察者订阅该 watcher 中的依赖，且该计算属性 watcher 会将订阅它的 watcher 推入他的 subs 中(当计算属性值改变的时候，通知订阅他的 watcher 观察者)watcher.evaluate()，该方法是通过调用 watcher 的 get 方法(其中需要注意的是 watcher 的 get 方法会调用 pushTarget 将之前的 Dep.target 实例入栈，并设置 Dep.target 为该 computed watcher,被该计算属性依赖的响应式属性会将该 computed watcher 推入其 subs 中，所以当被依赖的响应式属性改变时，会通知订阅他的 computed watcher,computed watcher 再通知订阅该计算属性的 watcher 调用 update 方法)，get 方法中调用计算属性 key 绑定的 handler 函数计算出值。 initWatch该 watcher 为 user watcher（开发人员自己在组件中自定义的）。initWatch 的作用是遍历 watch 中的属性，并对每个 watch 监听的属性调用定义的$watch 12345678910111213141516171819Vue.prototype.$watch = function( expOrFn: string | Function, cb: any, options?: Object): Function { const vm: Component = this; if (isPlainObject(cb)) { return createWatcher(vm, expOrFn, cb, options); } options = options || {}; options.user = true; // 代表该watcher是用户自定义watcher const watcher = new Watcher(vm, expOrFn, cb, options); if (options.immediate) { cb.call(vm, watcher.value); } return function unwatchFn() { watcher.teardown(); };}; 代码中调用 new Watcher 的时候，也会同 render watcher 一样，执行下 watcher 的 get 方法，调用pushTarget将当前 user watcher 赋值给 Dep.target,get()中value = this.getter.call(vm, vm)这个语句会触发该自定义 watcher 监听的响应式属性的 get 方法，并将当前的 user watcher 推入该属性依赖的 subs 中，所以当 user watcher 监听的属性 set 触发后，通知订阅该依赖的 watcher 去触发 update，也就是触发该 watch 绑定的 key 对应的 handler。然后就是调用 popTarget 出栈并赋值给 Dep.target。 $mountinitState 初始化工作大致到这里过，接下去会执行$mount开始渲染工作$mount 主要工作：new 了一个渲染 Watcher，并将 updateCompent 作为 callback 传递进去并执行 12345678910111213141516updateComponent = () =&gt; { vm._update(vm._render(), hydrating);};new Watcher( vm, updateComponent, noop, { before() { if (vm._isMounted) { callHook(vm, 'beforeUpdate'); } } }, true /* isRenderWatcher */); 三种 watcher 中 new Watcher 的时候，只有 computed watcher 不会一开始就执行它的 get()方法。$mount 里面 new 的这个 render watcher 会调用get()方法，调用pushTarget将当前 render watcher 赋值给 Dep.target。接下去重头戏来了，调用updateComponent,该方法会执行vm._update(vm._render(), hydrating)，其中 render 函数会触发 html 中使用到的响应式属性的 get 钩子。get 钩子会让该响应式属性的依赖实例 dep 将当前的 render watcher 推入其 subs 数组中，所以当依赖的响应式属性改变之后，会遍历 subs 通知订阅它的 watcher 去调用 update()。 例子可能大家对 watcher 和 dep 调来调去一头雾水，我讲个实例 1234567891011121314151617&lt;div id='app'&gt; &lt;div&gt;{{ a }}&lt;/div&gt; &lt;div&gt;{{ b }}&lt;/div&gt;&lt;/div&gt;;new Vue({ el: '#app', data() { return { a: 1 }; }, computed: { b() { return a + 1; } }}); 我直接从渲染开始讲，只讲跟 dep 跟 watcher 有关的$mount：new 一个渲染 watcher（watcher 的 get 方法中会将渲染 watcher 赋值给 Dep.target）的时候会触发 vm._update(vm._render(), hydrating)，render 的时候会获取 html 中用到的响应式属性，上面例子中先用到了 a,这时会触发 a 的 get 钩子,其中dep.depend()会将当前的渲染 watcher 推入到 a 属性的 dep 的 subs 数组中。接下去继续执行，访问到 b（b 是计算属性的值），会触发计算属性的 get 方法。计算属性的 get 方法是调用createComputedGetter函数后的返回函数computedGetter，computedGetter函数中会执行watcher.depend()。Watcher 的 depend 方法是专门留给 computed watcher 使用的。刚才上面说过了除了 computed watcher，其他两种 watcher 在 new 完之后都会执行他们的 get 方法，那么 computed watcher 在 new 完之后干嘛呢，它会 new 一个 dep。回到刚才说的专门为 computed watcher 开设的方法watcher.depend()，他的作用是执行this.dep.depend()（computed watcher 定义的 dep 就是在这里使用到的）。this.dep.depend()会让当前的渲染 watcher 订阅该计算属性依赖，该计算属性也会将渲染 watcher 推入到它自己的 subs（[render watcher]）中，当计算属性的值修改之后会通知 subs 中的 watcher 调用update(),所以计算属性值变了页面能刷新。回到前面说的触发 b 计算属性的 get 钩子那里，get 钩子最后会执行watcher.evaluate(),watcher.evaluate()会执行 computed watcher 的get()方法。这时候重点来了，会将 Dep.target（render watcher）推入 targetStack 栈中（存入之后以便待会儿取出继续用），然后将这个计算属性的 computed watcher 赋值给 Dep.target。get 方法中value = this.getter.call(vm, vm),会执行 computed 属性绑定的 handler。如上面例子中 return a + 1。使用了 a 那么就一定会触发 a 的 get 钩子，get 钩子又会调用dep.depend()，dep.depend()会让 computed watcher 将 dep 存入它的 deps 数组中，a 的 dep 会将当前的 Dep.target(computed watcher)存入其 subs 数组中，当前例子中 a 的 subs 中就会是[render watcher,computed watcher],所以 a 值变化会遍历 a 的 subs 中的 watcher 调用update()方法，html 中用到的 a 会刷新，计算属性 watcher 调用update()方法会通知他自己的 subs（[render watcher]）中 render watcher 去调用 update 方法，html 中用到的计算属性 b 才会刷新 dom（这里提个醒，我只是粗略的讲，计算属性依赖的属性变化后他不一定会触发更新，他会比较计算完之后的值是否变化）。computed watcher 的 get()方法最后会调用popTarget(),将之前存入 render watcher 出栈并赋值给 Dep.target，这时候我例子中 targetStack 就变成空数组了。render watcher 的 get 方法执行到最后也会出栈，这时候会将 Dep.target 赋值会空。","link":"/blog/2018/09/10/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"},{"title":"配置nginx解决vue路由history模式下刷新404问题","text":"在 vue 路由模式为 history 的时候，刷新页面会出现 404 问题。我们只需要在服务器配置如果 URL 匹配不到任何静态资源，就跳转到默认的 index.html。 123456789server { listen 8105; // 表示你nginx监听的端口号 root /home/admin/sites/vue-nginx/dist; // vue打包后的文件夹dist目录 index index.html; location / { try_files $uri $uri/ /index.html; }}","link":"/blog/2018/09/11/%E9%85%8D%E7%BD%AEnginx%E8%A7%A3%E5%86%B3vue%E8%B7%AF%E7%94%B1history%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%88%B7%E6%96%B0404%E9%97%AE%E9%A2%98/"},{"title":"阻止中文输入法输入拼音的时候触发input事件","text":"前言最近看 element-ui 源码的时候看到 el-input 发现的这个少见的事件。 compositionstart、compositionend事件（MDN 解释)compositionstart事件触发于一段文字的输入之前（类似于 keydown 事件，但是该事件仅在若干可见字符的输入之前，而这些可见字符的输入可能需要一连串的键盘操作、语音识别或者点击输入法的备选词）。当文本段落的组成完成或取消时, compositionend 事件将被触发 (具有特殊字符的触发, 需要一系列键和其他输入, 如语音识别或移动中的字词建议)。 123456789101112131415161718192021222324252627282930/** * @param {Element} elem input元素 * @param {Function} callback input事件绑定的回调 */function inputEvent(elem, callback) { let isOnComposition = false; elem.addEventListener('compositionstart', function(event) { isOnComposition = true; }); elem.addEventListener('compositionend', function(event) { isOnComposition = false; const val = event.target.value; handleInput(val); }); elem.addEventListener('input', function(event) { const val = event.target.value; handleInput(val); }); function handleInput(val) { if (isOnComposition) return; callback(val); }}window.onload = function() { const input = document.getElementById('input'); inputEvent(input, function(val) { console.log(val); });};","link":"/blog/2018/11/12/%E9%98%BB%E6%AD%A2%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E8%BE%93%E5%85%A5%E6%8B%BC%E9%9F%B3%E7%9A%84%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91input%E4%BA%8B%E4%BB%B6/"},{"title":"javascript数据结构学习笔记","text":"数组 方法123456789101112//一、数组var arr = [];// 添加元素arr.push(1, 2); // [1,2]// 开头插入arr.unshift(0); // [0, 1, 3]// 尾部删除arr.pop(); // [0, 1]// 头部删除arr.shift(); // [1]// 数组合并[1].concat([2]); // [1,2] 迭代器 every every 方法会迭代数组中每个元素，直到返回 false。 some some 和 every 类似，不过 some 方法会迭代数组的每个元素，直到函数返回 true forEach 和 for 循环的结果相同 map 返回新的数组 [1,2].map(o =&gt; o * 2) // [2,4] filter 返回新的数组 [1,2].filter(o =&gt; o &gt; 1) // [2] reduce [1,2].reduce((result, current) =&gt; result + current) // 3 for of for (let n of numbers) { console.log((n % 2 === 0) ? 'even' : 'odd')}; entries 12345const numbers = [1, 2, 3];let aEntries = numbers.entries(); // 得到键值对的迭代器console.log(aEntries.next().value); // [0, 1] 位置0的值为1console.log(aEntries.next().value); // [1, 2] 位置1的值为2console.log(aEntries.next().value); // [2, 3] 位置2的值为3 keys 12const numbers = [1, 2, 3];console.log(Object.keys(numbers)); // ['0','1','2']; values 12const numbers = [1, 2, 3];console.log(Object.values(numbers)); // [1,2,3] Array.from Array.of fill copyWithin sort find findIndex includes 栈 栈是一种遵从后进先出原则的有序集合 实现1234567891011121314151617181920212223242526272829function Stack() { let items = []; // 向栈添加元素 this.push = function(element) { items.push(element); }; // 从栈移除元素 this.pop = function() { return items.pop(); }; // 查看栈顶元素 this.peek = function() { return items[item.length - 1]; }; // 检查栈是否为空 this.isEmpty = function() { return items.length == 0; }; this.size = function() { return items.length; }; // 清空和打印栈元素 this.clear = function() { items = []; }; this.print = function() { console.log(items.toString()); };} 用栈解决问题存储访问过的任务或路径、撤销的操作等。 队列 队列是遵循 FIFO(First In First Out, 先进先出，也称为先来先服务) 实现1234567891011121314151617181920212223242526function Queue() { let items = []; // 向队列添加元素 this.enqueue = function(element) { items.push(element); }; // 从队列移除元素 this.dequeue = function() { return items.shift(); }; // 查看队列头元素 this.front = function() { return items[0]; }; // 检查队列是否为空 this.isEmpty = function() { return items.length == 0; }; this.size = function() { return items.length; }; // 打印队列元素 this.print = function() { console.log(items.toString()); };} 链表 链表村粗有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122function LinkedList() { let Node = function(element) { this.element = element; this.next = null; }; let length = 0; let head = null; // 向链表尾部追加元素 this.append = function(element) { let node = new Node(element), current; if (head === null) { head = node; } else { current = head; // 循环列表，直到找到最后一项 while (current.next) { current = current.next; } // 找到最后一项，将其next赋为node，建立链接 current.next = node; } length++； // 更新列表的长度 } // 从链表中移除元素 this.removeAt = function() { // 检查越界值 if (position &gt; -1 &amp;&amp; position &lt; length) { let current = head, previous, index = 0; // 移除第一项 if (position === 0) { head = current.next; } else { while (index++ &lt; position) { previous = current; current = current.next; } // 将previous 与 current的下一项链接起来： 跳过current，从而移除它 previous.next = current.next; } length--; return current.element; } else { return null; } } // 在任意位置插入元素 this.insert = function(position, element) { // 检查越界值 if (position &gt;= 0 &amp;&amp; position &lt;= length) { let node = new Node(element), current = head, previous, index = 0; if (position === 0) { // 在第一个位置添加 node.next = current; head = node; } else { while (index++ &lt; position) { previous = current; current = current.next; } node.next = current; previous.next = node; } length++; // 更新列表的长度 return true; } else { return false; } } // toString方法 this.toString = function() { let current = head, string = ''; while (current) { string += current.element + (current.next ? 'n' : ''); current = current.next; } return string; } // indexOf 方法 this.indexOf = function(elment) { let current = head, index = 0; while(current) { if (element === current.element) { return index; } index++; current = current.next; } return -1; } // remove 方法 this.remove = function(elment) { let index = this.indexOf(element); return this.removeAt(index); } // isEmpty 方法 this.isEmpty = function() { return length == 0; } // size 方法 this.size = function() { return length; } // getHead 方法 this.getHead = function() { return head; }} 双向链表（留给大家自己思考）集合 集合是由一组无序且唯一（即不能重复）的项组合的。这个数据结构使用了与有限集合相同的数学概念，但应用在计算机科学的数据结构中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495function Set() { let items = {}; // has 方法 this.has = function(value) { return items.hasOwnProperty(value); }; // add 方法 this.add = function(value) { if (!this.has(value)) { items[value] = value; return true; } return false; }; // remove 方法 this.remove = function(value) { if (this.has(value)) { delete items[value]; return true; } return false; }; // clear 方法 this.clear = function() { items = {}; }; // size 方法 this.size = function() { return Object.keys(items).length; }; // values 方法 this.values = function() { let values = []; for (let i = 0, keys = Object.keys(items); i &lt; keys.length; i++) { values.push(items[keys[i]]); } return values; }; // 并集 this.union = function(otherSet) { let unionSet = new Set(); let values = this.values(); for (let i = 0; i &lt; values.length; i++) { unionSet.add(values[i]); } values = otherSet.values(); for (let i = 0; i &lt; values.length; i++) { unionSet.add(values[i]); } return unionSet; }; // 交集 this.intersection = function(otherSet) { let intersectionSet = new Set(); let values = this.values(); for (let i = 0; i &lt; values.length; i++) { if (otherSet.has(values[i])) { intersectionSet.add(values[i]); } } return intersectionSet; }; // 差集 this.difference = function(otherSet) { let differenceSet = new Set(); let values = this.values(); for (let i = 0; i &lt; values.length; i++) { if (!otherSet.has(values[i])) { differenceSet.add(values[i]); } } return differenceSet; }; // 子集 this.subset = function(otherSet) { if (this.size() &gt; otherSet.size()) { return false; } else { let values = this.values(); for (let i = 0; i &lt; values.length; i++) { if (!otherSet.has(values[i])) { return false; } } return true; } };} 字典和散列表实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Dictionary() { var items = {}; // has 和 set 方法 this.has = function(key) { return items.hasOwnProperty(key); }; this.set = function(key, value) { item[key] = value; }; // delete 方法 this.delete = function(key) { if (this.has(key)) { delete items[key]; return true; } return false; }; // get 和 values 方法 this.get = function(key) { return this.has(key) ? items[key] : undefined; }; this.values = function() { var values = []; for (var k in items) { if (this.has(k)) { values.push(items[k]); } } return values; }; // clear 方法 this.clear = function() { items = {}; }; // size 方法 this.size = function() { return Object.keys(items).length; }; // keys 方法 this.keys = function() { return Object.keys(items); }; // getItems 方法 this.getItems = function() { return items; };} 散列表 HashTable 类 也叫 HashMap 类，它是 Dictionary 类的一种散列表是实现方式。散列算法的作用是尽可能快的在数据结构中找到一个值。 123456789101112131415161718192021function HashTable() { var table = []; var loseloseHashCode = function(key) { var hash = 0; for (var i = 0; i &lt; key.length; i++) { hash += key.charCodeAt(i); } return hash % 37; }; this.put = function(key, value) { var position = loseloseHashCode(key); console.log(position + ' - ' + key); table[position] = value; }; this.get = function(key) { return table[loseloseHashCode(key)]; }; this.remove = function(key) { table[loseloseHashCode(key)] = undefined; };} Map 类 es6 新增了 Map 类 12345678910var map = new Map();map.set('a', 'b');console.log(map.has('a')); // trueconsole.log(map.size()); // 输出1console.log(map.keys()); // ['a']console.log(map.values()); // ['b'];// 和Dictionary类不同，es6的Map类的values方法和keys方法都返回Iterator，而不是值或键构成的数组。 es6 — WeakMap 类 和 WeakSet 类 WeakMap 和 WeakSet 类没有 entries keys values 等方法 只能用对象作为键 1234567var map = new WeakMap();var obj = { name: 'a' };map.set(obj, 'b');console.log(map.has(obj)); // 输出trueconsole.log(map.get(obj)); // 输入'b'map.delete(obj); 树 一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点； 二叉树和二叉搜索树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169function BinarySearchTree() { var Node = function(key) { this.key = key; this.left = null; this.right = null; }; var root = null; var insertNode = function(node, newNode) { if (newNode.key &lt; node.key) { if (node.left === null) { node.left = newNode; } else { insertNode(node.left, newNode); } } else { if (node.right === null) { node.right = newNode; } else { insertNode(node.right, newNode); } } }; // 向树中插入一个键 this.insert = function(key) { var newNode = new Node(key); if ((root = null)) { root = newNode; } else { insertNode(root, newNode); } }; var inOrderTraverseNode = function(node, callback) { if (node !== null) { inOrderTraverseNode(node.left, callback); callback(node.key); inOrderTraverseNode(node.right, callback); } }; // 中序遍历 this.inOrderTraverse = function(callback) { inOrderTraverseNode(root, callback); }; var preOrderTraverseNode = function(node, callback) { if (node !== null) { callback(node.key); preOrderTraverseNode(node.left, callback); preOrderTraverseNode(node.right, callback); } }; // 先序遍历 this.preOrderTraverse = function(callback) { preOrderTraverseNode(root, callback); }; var postOrderTraverseNode = function(node, callback) { if (node !== null) { postOrderTraverseNode(node.left, callback); postOrderTraverseNode(node.right, callback); callback(node.key); } }; // 后序遍历 this.postOrderTraverse = function(callback) { postOrderTraverseNode(root, callback); }; // 搜索最小值 this.min = function() { return minNode(root); }; var minNode = function(node) { if (node) { while (node &amp;&amp; node.left !== null) { node = node.left; } return node.key; } return null; }; // 搜索最大值 this.max = function() { return maxNode(root); }; var maxNode = function(node) { if (node) { while (node &amp;&amp; node.right !== null) { node = node.right; } return node.key; } return null; }; // 搜索一个特定的值 this.search = function(key) { return searchNode(root, key); }; var searchNode = function(node, key) { if (node === null) { return false; } if (key &lt; node.key) { return searchNode(node.left, key); } else if (key &gt; node.key) { return searchNode(node.right, key); } else { return true; } }; // 移除一个节点 this.remove = function(key) { root = removeNode(root, key); }; var removeNode = function(node, key) { if (node === null) { return null; } if (key &lt; node.key) { node.left = removeNode(node.left, key); return node; } else if (key &gt; node.key) { node.right = removeNode(node.right, key); return node; } else { // 键等于node.key // 第一种情况--一个叶节点 if (node.left === null &amp;&amp; node.right === null) { node = null; return node; } // 第二种情况--一个只有一个子节点的节点 if (node.left === null) { node = node.right; return node; } else if (node.right === null) { node = node.left; return node; } // 第三种情况---- 一个有两个子节点的节点 var aux = findMinNode(node.right); node.key = aux.key; node.right = removeNode(node.rihgt, aux.key); return node; } var findMinNode = function(node) { while (node &amp;&amp; node.left !== null) { node = node.left; } return node; }; };} 自平衡树（AVL) 当树很深的时候，添加移除和搜索某个节点时引起一些性能问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var heightNode = function(node) { if (node === null) { return -1; } else { return Math.max(heightNode(node.left), heightNode(node.right)) + 1; }}var rotationRR = function(node) { var tmp = node.right; node.right = tmp.left; tmp.left = node; return tmp;}var rotationLL = function(node) { var tmp = node.left; node.left = tmp.right; tmp.right = node; return tmp;}var rotationLR = function(node) { node.left = rotationRR(node.left); return rotationLL(node);}var rotationRL = function(node) { node.right = rotationLL(node.right); return rotationRR(node);}var insertNode = function(node, element) { if (node === null) { node = new Node(element); } else if (element &lt; node.key) { node.left = insertNode(node.left, element); if (node.left !== null) { // 确认是否需要平衡 if ((heightNode(node.left) - heightNode(node.right) &gt; 1)) { if (element &lt; node.left.key) { node = rotationLL(node); } else { node = rotationLR(node); } } } } else if (element &gt; node.key) { node.right = insertNode(node.right, element); if (node.right !== null) { // 确认是否需要平衡 if ((heightNode(node.right) - heightNode(node.left) &gt; 1)) { if (element &gt; node.right.key) { node = rotationRR(node); } else { node = rotationRL(node); } } } } return node;} 图 图是网络结构的抽象模型，图是一组由边连接的节点（或顶点）。学习图是重要的，因为任何关系都可以用图来表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163function Graph() { var vertices = []; var adjList = new Dictionary(); this.addVertex = function(v) { vartices.push(v); adjList.set(v, []); }; this.addEdge = function(v, w) { addList.get(v).push(w); addList.get(w).push(v); }; this.toString = function() { var s = ''; for (var i = 0; i &lt; vertices.length; i++) { s += vertices[i] + ' -&gt; '; var neighbors = adjList.get(vertices[i]); for (var j = 0; j &lt; neighbors.length; j++) { s += neighbors[j] + ' '; } s += '\\n'; } return s; }; // 广度优先搜索 var initializeColor = function() { var color = []; for (var i = 0; i &lt; vertices.length; i++) { color[vertices[i]] = 'white'; } return color; }; this.bfs = function(v, callback) { var color = initializeColor(), queue = new Queue(); queue.enqueue(v); while (!queue.isEmpty()) { var u = queue.dequeue(), neighbors = adjList.get(u); color[u] = 'grey'; for (var i = 0; i &lt; neighbors.length; i++) { var w = neighbors[i]; if (color[w] === 'white') { color[w] = 'grey'; queue.enqueue(w); } } color[u] = 'black'; if (callback) { callback(); } } }; // 使用BFS寻找最短路径 this.BFS = function(v) { var color = initializeColor(), queue = new Queue(), d = []; pred = []; queue.enqueue(v); for (var i = 0; i &lt; vertices.length; i++) { d[vertices[i]] = 0; pred[vertices[i]] = null; } while (!queue.isEmpty()) { var u = queue.dequeue(), neighbors = adjList.get(u); color[u] = 'grey'; for (i = 0; i &lt; neighbors.length; i++) { var w = neighbors[i]; if (color[w] === 'white') { color[w] = 'grey'; d[w] = d[u] + 1; pred[w] = u; queue.enqueue(w); } } color[u] = 'black'; } return { distances: d, predecessors: pred }; }; // 深度优先遍历 var dfsVisit = function(u, color, callback) { color[u] = 'grey'; if (callback) { callback(u); } var neighbors = adjList.get(u); for (var i = 0; i &lt; neighbors.length; i++) { var w = neighbors[i]; if (color[w] === 'white') { dfsVisit(w, color, callback); } } color[u] = 'black'; }; this.dfs = function(callback) { var color = initializeColor(); for (var i = 0; i &lt; vertices.length; i++) { if (color[vertices[i]] === 'white') { dfsVisit(vertices[i], color, callback); } } }; // 探索深度优先算法 var time = 0; this.DFS = function() { var color = nitializeColor(), d = [], f = [], p = [], time = 0; for (var i = 0; i &lt; vertices.length; i++) { f[vertices[i]] = 0; d[vertices[i]] = 0; p[vertices[i]] = null; } for (i = 0; i &lt; vertices.length; i++) { if (color[vertices[i]] === 'white') { DFSVisit(vertices[i], color, d, f, p); } } return { discovery: d, finished: f, predecessors: p }; }; var DFSVisit = function(u, color, d, f, p) { console.log('discovered ' + u); color[u] = 'grey'; d[u] = ++time; var neighbors = adjList.get(u); for (var i = 0; i &lt; neighbors.length; i++) { var w = neighbors[i]; if (color[w] === 'white') { p[w] = u; DFSVisit(w, color, d, f, p); } } color[u] = 'black'; f[u] = ++time; console.log('explored ' + u); };}","link":"/blog/2019/03/04/javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"javaScript排序算法学习笔记","text":"直接上demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196// 用于创建数组function createNonSortedArray(size) { var array = new ArrayList(); for (var i = size; i &gt; 0; i--) { array.insert(i); } return array;}function ArrayList() { var array = []; this.insert = function(item) { console.log(item, 'insert'); array.push(item); }; this.toString = function() { console.log('tostring'); return array.join(); }; /* * 冒泡排序 * 冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。 * 元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。 * 第一轮比过之后最后一个就一定是最大的 无需再比较。所以下次要 - i */ this.bubbleSort = function() { var length = array.length; for (var i = 0; i &lt; length; i++) { for (var j = 0; j &lt; length - 1 - i; j++) { if (array[j] &gt; array[j + 1]) { swap(array, j, j + 1); } } } }; /* * 选择排序 * 选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值 * 并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。比如，第一个 * 的时候，会遍历后面所有想跟其比较，找到最小的更其交换。所以第一个此时一定是最小的。 * 随意第二个的时候，只会循环后面的几个。如果找到一个比第二个更小的，那么交换位置。 */ this.selectionSort = function() { var length = array.length, indexMin; for (var i = 0; i &lt; length - 1; i++) { indexMin = i; for (var j = i; j &lt; length; j++) { if (array[indexMin] &gt; array[j]) { indexMin = j; } } if (i !== indexMin) { swap(array, i, indexMin); } } }; /* * 插入排序 * 插入排序每次排第一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了，接着， * 它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确 * 排序，接着和第三项比较（它是该插入到第一、第二还是第三位置呢？），以此类推。 * 简而言之，就是遍历数组的每一项，拿这一项去跟前面的项比较，如果比他小就插入到它前面。 */ this.insertionSort = function() { var length = array.length, j, temp; for (var i = 1; i &lt; length; i++) { j = i; temp = array[i]; while (j &gt; 0 &amp;&amp; array[j - 1] &gt; temp) { array[j] = array[j - 1]; j--; } array[j] = temp; } }; // 归并排序 // 归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个 // 小数组只有一个位置，接着将小数组归并成较大的数组，直到最后一个排序完毕的大数组。 this.mergeSort = function() { array = mergeSortRec(array); }; var mergeSortRec = function(array) { var length = array.length; if (length === 1) { return array; } var mid = Math.floor(length / 2), left = array.slice(0, mid), right = array.slice(mid, length); return merge(mergeSortRec(left), mergeSortRec(right)); }; var merge = function(left, right) { var result = [], il = 0, ir = 0; // 完成下列操作的前提是left、right数组均已经完成。所以采用递归的形式 // 在数组长度为1的时候先开始排序，然后在通过merge left与right数组 while (il &lt; left.length &amp;&amp; ir &lt; right.length) { if (left[il] &lt; right[ir]) { result.push(left[il++]); } else { result.push(right[ir++]); } } // 上面是将left与right数组排完序，那么其中之一数组必然为空， // 下面的操作就是将剩下的right或者left全部推入result数组中 while (il &lt; left.length) { result.push(left[il++]); } while (ir &lt; right.length) { result.push(right[ir++]); } return result; }; // 快速排序 // 首先，从数组中选择中间一项作为主元 // 创建两个指针，左边一个指向数组的第一项，右边一个指向数组的最后一个项。 // 移动左指针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个 // 比主元小的元素，然后交换他们，重复这个过程，直到左指针超过右指针。这个 // 过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步 // 叫做划分操作。 // 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值 // 组成的子数组）重复之前的两个步骤，直到数组已完全排序。 // 简而言之，先分治，不断的细化下去，到最后一个数组无法再交换位置进行排序位置 this.quickSort = function() { quick(array, 0, array.length - 1); }; var quick = function(array, left, right) { var index; if (array.length &gt; 1) { index = partition(array, left, right); if (left &lt; index - 1) { quick(array, left, index - 1); } if (index &lt; right) { quick(array, index, right); } } }; var partition = function(array, left, right) { var pivot = array[Math.floor((left + right) / 2)], i = left, j = right; while (i &lt;= j) { while (array[i] &lt; pivot) { i++; } while (array[j] &gt; pivot) { j--; } if (i &lt;= j) { swap(array, i, j); i++; j--; } } return i; }; var swap = function(array, index1, index2) { var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux; };}var array = createNonSortedArray(9);console.log(array.toString());array.bubbleSort();// array.selectionSort();// array.insertionSort();// array.mergeSort();// array.quickSort();console.log(array.toString());","link":"/blog/2019/03/12/javaScript%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"vue ssr从认识到构建一个工程项目（一）","text":"vue ssr 入门前言近期需要接手一个 vue ssr 项目，由于本人之前没有写过 ssr，只是稍微了解了点。所以跟着官网学了下，并整理出了这篇学习笔记。方便自己以后对 vue ssr 知识的回顾。好记性不如烂笔头。 介绍相信大家在看到这篇文章之前，都知道 ssr 是什么了。SSR，英文全称叫 Server(服务) side(端) rendering (渲染)哈哈 ☺ 那么究竟什么是服务器端渲染？ Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。 服务器渲染的 Vue.js 应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。 如果你问我为什么使用 ssr 呢？(具体可参考官网) 有利于 seo。 更快的内容到达时间 (time-to-content),特别是对于缓慢的网络情况或运行缓慢的设备。大体可以理解为渲染出页面时间，csr 比 ssr 多了个 js 下载时间。因为 ssr 一开始加载下来就渲染出来了，然后在下载激活 html 的 js。csr 是下载完在渲染。 正文基本用法ssr 主要依靠两个包vue-server-renderer和 vue(两个版本必须匹配) 安装: npm install vue vue-server-renderer --save 入门配置ssr 最简易配置12345678910111213141516171819202122232425262728// server.jsconst server = require('express')();const Vue = require('vue');const renderer = require('vue-server-renderer').createRenderer();server.get('*', (req, res) =&gt; { const context = { url: req.url }; const app = new Vue({ template: `&lt;div&gt;${context.url}&lt;/div&gt;` }); renderer.renderToString(app, (err, html) =&gt; { if (err) { res.status(500).end('Internal Server Error'); return; } res.end(` &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt; &lt;body&gt;${html}&lt;/body&gt; &lt;/html&gt; `); });});server.listen(8080); node server.js 浏览器输入 localhost:8080 访问该 ssr 页面 这时候你可以看到，无论你输入什么路径，页面文本都会显示出你的路径 ssr 使用模板当你在渲染 Vue 应用程序时，renderer 只从应用程序生成 HTML 标记 (markup)。在这个示例中，我们必须用一个额外的 HTML 页面包裹容器，来包裹生成的 HTML 标记。纯客户端渲染的时候，会有一个模板，会插入你打包后的一些文件等。那么 ssr 会不会也有这种模板呢？当然会有。 首先在根目录下新建一个index.template.html文件 123456789&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;title&gt;Hello&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--vue-ssr-outlet--&gt; &lt;/body&gt;&lt;/html&gt; 注意了 –跟 vue 或者 outlet 跟–之间不能用空格。注释 – 这里将是应用程序 HTML 标记注入的地方。 接下来，修改下刚才的 server.js 文件后如下 12345678910111213141516171819202122const server = require('express')();const Vue = require('vue');const renderer = require('vue-server-renderer').createRenderer({ template: require('fs').readFileSync('./index.template.html', 'utf-8')});server.get('*', (req, res) =&gt; { const context = { url: req.url }; const app = new Vue({ template: `&lt;div&gt;${context.url}&lt;/div&gt;` }); renderer.renderToString(app, (err, html) =&gt; { if (err) { res.status(500).end('Internal Server Error'); return; } res.end(html); });});server.listen(8080); 就是在 createRenderer 中多加一个参数 template(读取模板文件)，并传递给 createRenderer 方法 模板还支持插值 123456789101112&lt;html&gt; &lt;head&gt; &lt;!-- 使用双花括号(double-mustache)进行 HTML 转义插值(HTML-escaped interpolation) --&gt; &lt;title&gt;{{ title }}&lt;/title&gt; &lt;!-- 使用三花括号(triple-mustache)进行 HTML 不转义插值(non-HTML-escaped interpolation) --&gt; {{{ meta }}} &lt;/head&gt; &lt;body&gt; &lt;!--vue-ssr-outlet--&gt; &lt;/body&gt;&lt;/html&gt; 我们可以通过传入一个”渲染上下文对象”，作为 renderToString 函数的第二个参数，来提供插值数据： 123456789101112const context = { title: 'hello', meta: ` &lt;meta ...&gt; &lt;meta ...&gt; `};renderer.renderToString(app, context, (err, html) =&gt; { // 页面 title 将会是 \"Hello\" // meta 标签也会注入}); 编写通用代码我们以往的纯浏览器渲染都是把 js 下载到本地执行的。上述代码你会发现都是用的同一个 Vue 构造函数，但是想对该构造函数做特殊处理时，就会对其他用户造成污染。因此，我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例： 123456789101112131415161718// 修改原先代码如下-const Vue = require('vue');+const createApp = require('./app.js')- const app = new Vue({- template: `&lt;div&gt;${context.url}&lt;/div&gt;`- })+ const { app } = createApp(context)// 新增app.jsconst Vue = require('vue');module.exports = function createApp(context) { const app = new Vue({ template: `&lt;div&gt;${context.url}&lt;/div&gt;` }) return { app }} 这样，每次访问该服务器的时候，都会生成一个新的 vue 实例。同样的规则也适用于 router、store 和 event bus 实例。你不应该直接从模块导出并将其导入到应用程序中，而是需要在 createApp 中创建一个新的实例，并从根 Vue 实例注入。 参考Vue SSR 指南 vue 服务端渲染 ssr 带你五步学会 Vue SSR","link":"/blog/2019/04/10/%E4%BB%8E%E8%AE%A4%E8%AF%86%E5%88%B0%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"webpack4学习笔记（一）","text":"前言这是我花了几个星期学习 webpack4 的学习笔记。内容不够细，因为一些相对比较简单的，就随意带过了。希望文章能给大家带来帮助。如有错误，希望及时指出。例子都在learn-webpack仓库上。如果你从中有所收获的话，希望你能给我的github点个star。 小知识npm info webpack 查看 webpack 的历史版本信息等npm init -y 跳过那些选项，默认全局安装的webpack ： webpack index.js 打包项目中安装的webpack：npx webpack index.js 打包script中脚本打包 ： npm run build命令行中打包：npx webpack index.js -o bundle.js 入口是index.js, 出口是bundle.jswebpack4设置mode：production 会压缩代码 development 就不压缩代码打包output里面[name].js loader中的name变量 其实就是entry:{main: index.js} 中的key =&gt; main source-mapdevtool: source-mapsource-map: dist文件夹里会多生成个map后缀文件，这样页面报错的时候，点击报错后面的地址，会跳转到代码写的地方。而不会跳转到打包后的代码里。inline-source-map: 不会新生成.map 文件，会插入到打包的文件底部cheap-inline-source-map: 因为inline-source-map报错会告诉你第几行第几个字符。前面加上cheap的话 只会告诉你第几行cheap-module-inline-source-map: 本来 map 只会映射打包出来的 index.js 跟业务代码中的关系。第三方引入库报错映射不到。中间加了 module 这个参数就可以了。比如loader也会有source-map开发的时候建议使用：cheap-module-eval-source-map,eval表示不会独立生成 map 文件，而是打包进代码里。一般development环境用 cheap-module-eval-source-mapproduction环境用cheap-module-source-map loader1234// style.cssbody { color: red;} 当你想给项目添加样式的时候，import ./style.css导入css，并执行打包命令的时候。页面并报错 123ERROR in ./style.css 1:5Module parse failed: Unexpected token (1:5)You may need an appropriate loader to handle this file type. 这个时候就需要使用loader来编译了。安装:npm i style-loader css-loader -D为什么还需要安装style-loader呢？因为style-loader会将你的样式通过style标签插入到页面中配置webpack.config.js 123456789101112131415161718// webpack.config.jsconst HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { mode: 'development', entry: './index.js', output: { filename: 'bundle.js' }, module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ] }, plugins: [new HtmlWebpackPlugin()]}; 上面使用了HtmlWebpackPlugin是因为我用它来自动生成index.html方便页面访问 1234// package.json\"scripts\": { \"build\": \"webpack --config webpack.config.js\"}, 执行npm run build进行打包，访问dist目录下的index.html,可以看到页面显示成功。loader执行顺序是从下到上，右到左。 webpack-dev-serverwebpack-dev-server webpack-dev-server会对你的代码进行打包，将打包的内容放到内存里面，并不会自动给你打包放进 dist 里。webpack —watch页面会刷新下，内容会自动更新webpack-dev-server会自动更新当前页面webpack-dev-server, 现在的webpack-dev-server比以前好多了 vue-cli3 和react都是用这个了 123456devServer: { contentBase: './dist', // 有这个就够了， open: true, // 自动打开浏览器 port: 8080, // 端口不必填 proxy: {'/api': http://localhost:3000}} 启动服务来热更新npm install express webpack-dev-middleware -D在output中添加publicPath 1234567891011121314const express = require('express');const webpack = require('webpack');const webpackDevMiddleWare = require('webpack-dev-middleware');const config = require('./webpack.config.js');const complier = webpack(config); // 帮我们做编译的东西，webpack传入config之后会申请一个编译器app.use( webpackDevMiddleware(complier, { publicPath: config.output.publicPath // 意思是只要文件改变了，就重新运行 }));const app = express();app.listen(3000, () =&gt; { console.log('server is running 3000');}); 现在这样子写太麻烦了（vue-cli2 也是如此）。因为以前版本webpack-dev-server还不够强大，现在不一样了。非常的强大了。 Hot Module Replacement 热替换，就是不会刷新整个页面。当不使用热更新的时候，操作一些功能，新增了三个元素，修改样式页面自动刷新后，刚才新增的元素会消失。如果开启了热替换，那么原先的 dom 会还在。 123456789101112const webpack = require('webpack') // .... devServer: { contentBase: './dist', open: true, hot: true, hotOnly: true // 以防hot失效后，页面被刷新，使用这个，hot失效也不刷新页面 }, // ... plugins: [ new webpack.HotModuleReplacementPlugin() ] 12345678import number from './number.js';if (module.hot) { // 如果热更新存在 // 监听的文件改变，会触发后面的回调方法 module.hot.accept('./number', () =&gt; { // dosomething });} 为什么修改了 css 文件不需要写 module.hot。而写 js 需要写呢，因为 css-loader 已经自动帮你处理了。 babel基本用法将高版本的 js 代码转换成低版本的 js 代码。比如 ie 浏览器不兼容 es6，需要使用 babel 把 es6 代码把 js 转换成低版本的 js 代码。安装：npm install --save-dev babel-loader @babel/core 123module: { rules: [{ test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader' }];} babel-loader并不会帮助你把 es6 语法转换成低级的语法。它只是帮助打通 webpack 跟 babel 之间的联系。转换成 es5 的语法：安装：npm install @babel/preset-env --save-dev@babel/preset-env包含了 es6 转换成 es5 的所有规则。 123456789101112module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader', options: { presets: ['@babel/preset-env'] } } ];} 如果还需要降到更低版本就得使用babel-polyfill安装：npm install --save @babel/polyfill页面顶部引入import &quot;@babel/polyfill&quot;;就可以将高级版本语法转换成低级语法。但是直接import会让打包后的文件非常大。这个时候就需要再配置webpack.config.jsuseBuiltIns 12345678910111213{ test: /\\.js$/, exclude: /node_modules/, loader: \"babel-loader\", options: { // \"presets\": [\"@babel/preset-env\"] // 当你做babel-polyfill往浏览器填充的时候，根据业务代码用到什么加什么，并不会全部写入, // 数组中，后面的对象是对数组前面的babel做配置 \"presets\": [[\"@babel/preset-env\", { useBuiltIns: 'usage' }]] }} 如果开发一个第三方库，类库。使用babel-polyfill会注入到全局，污染到全局环境。安装：npm install --save-dev @babel/plugin-transform-runtime安装：npm install --save @babel/runtime 12345678{ test: /\\.js$/, exclude: /node_modules/, loader: \"babel-loader\", options: { \"plugins\": [\"@babel/plugin-transform-runtime\"] }} 当你要添加配置时 1234567891011121314{ test: /\\.js$/, exclude: /node_modules/, loader: \"babel-loader\", options: { \"plugins\": [[\"@babel/plugin-transform-runtime\", { \"absoluteRuntime\": false, \"corejs\": false, \"helpers\": true, \"regenerator\": true, \"useESModules\": false }]] }} 如果你要将 corejs 赋值为 2安装：npm install --save @babel/runtime-corejs2 1234567891011121314{ test: /\\.js$/, exclude: /node_modules/, loader: \"babel-loader\", options: { \"plugins\": [[\"@babel/plugin-transform-runtime\", { \"absoluteRuntime\": false, \"corejs\": 2, \"helpers\": true, \"regenerator\": true, \"useESModules\": false }]] }} @babel/plugin-transform-runtime不会污染到全局环境。当 babel 配置非常多的时候，可以将他们放到.babelrc文件里在根目录下创建.babelrc文件将options里的代码放到这个文件中，如下： 123456789{ \"plugins\": [[\"@babel/plugin-transform-runtime\", { \"absoluteRuntime\": false, \"corejs\": 2, \"helpers\": true, \"regenerator\": true, \"useESModules\": false }]]} react 中应用 babel安装：npm install --save-dev @babel/preset-react往刚刚的.babelrc文件中添加配置 123456789// presets对应一个数组，如果这个值需要做配置，那么这个值在包装进一个数组，放到第一项，第二项是个对象，用于描述该babel{ \"presets\": [ [\"@babel/preset-env\", { \"useBuiltIns\": \"usage\" }], \"@babel/preset-react\" ]} 注意：转换是先下后上，就是使用 preset-react 转换 react 代码，再用 preset-env 将 js 代码转换为 es5 代码","link":"/blog/2019/05/15/webpack4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"webpack4学习笔记（二）","text":"前言这是我花了几个星期学习 webpack4 的学习笔记。内容不够细，因为一些相对比较简单的，就随意带过了。希望文章能给大家带来帮助。如有错误，希望及时指出。例子都在learn-webpack仓库上。如果你从中有所收获的话，希望你能给我的github点个star。 tree shaking一个模块里会导出很多东西。把一个模块里没有被用到的东西都给去掉。不会把他打包到入口文件里。tree shaking 只支持 es6 的方式引入(import)，使用require无法使用tree shaking。 webpack的development无法使用tree shaking功能。除非在打包的配置里加上 1234// 开发环境需要加如下代码optimization: { usedExports: true;} 当你需要 import 某个模块，又不想tree shaking把他给干掉，就需要在 package.json 里修改sideEffects参数。比如当你import './console.js', import './index.css'等没有export(导出)模块的文件。又不想tree shaking把它干掉。 1234// package.jsonsideEffects: ['./console.js', './index.css'];// 反之sideEffects: false; 在development环境即使你使用tree shaking，它也不会把其他多余的代码给干掉。他只会在打包的文件里注明某段代码是不被使用的。 development 和 production 区别development代码不压缩，production代码会压缩 省略…☺ webpack-merge react和vue都会区分环境进行不同的webpack配置,但是它们一定会有相同的部分。这个时候需要通过使用webpack-merge进行抽离。 1234567891011121314151617181920212223242526272829303132333435363738// webpack.base.config.jsconst path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { mode: 'production', // mode: 'development', entry: './index.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, './dist') }, module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ] }, optimization: { usedExports: true }, plugins: [ new HtmlWebpackPlugin({ template: './index.html' }) ]};// webpack.dev.config.jsconst merge = require('webpack-merge');const baseConfig = require('./webpack.base.config');const devConfig = { mode: 'development'};module.exports = merge(baseConfig, devConfig); 这里就不重复把production环境在配置出来了，主要介绍下webpack-merge用法。 安装npm i webpack-merge -D 新建一个公共的文件如：webpack.base.config.js 将development和production两个webpack配置相同的抽离到webpack.base.config.js文件中 在环境配置文件中(具体代码如上) const merge = require('webpack-merge') const baseConfig = require('./webpack.base.config.js') module.exports = merge(baseConfig, devConfig) code splitting和splitChunks当你把所有的代码都打包到一个文件的时候，每次改一个代码都需要重新打包。且用户都要重新加载下这个 js 文件。但是如果你把一些公共的代码或第三方库抽离并单独打包。通过缓存加载，会加快页面的加载速度。 异步加载的代码，webpack 会单独打包到一个 js 文件中 同步加载的代码有两种方式 原始代码 123import _ from 'lodash';console.log(666); 打包后的文件： main.js 551 KiB main [emitted] main可以看到，webpack 将业务代码跟 lodash 库打包到一个 main.js 文件了 方法一： 创建一个新文件 12import _ from 'lodash';window._ = _; 将文件挂载到window对象上,这样其他地方就可以直接使用了。 然后在 webpack 配置文件中的 entry 增加一个入口为该文件。让该文件单独打包。 123 Asset Size Chunks Chunk Nameslodash.js 551 KiB lodash [emitted] lodash main.js 3.79 KiB main [emitted] main 方法二： 通过添加optimization配置参数 optimization: 会将诸如lodash等库抽离成单独的chunk,还会将多个模块公用的模块抽离成单独的chunk 12345optimization: { splitChunks: { chunks: 'all' }}, 打包后文件： 123 Asset Size Chunks Chunk Names main.js 6.78 KiB main [emitted] mainvendors~main.js 547 KiB vendors~main [emitted] vendors~main 可以看到，webpack 将 lodash 抽成公共的 chunk 打包出来了。 splitChunks里面还可以在添加个参数cacheGroups 1234567891011121314optimization: { splitChunks: { chunks: 'all', cacheGroups: { // 下面的意思是：将从node_modules中引入的模块统一打包到一个vendors.js文件中 vendors: { test: /[\\\\/]node_modules[\\\\/]/, priority: -10, filename: 'vendors.js' }, default: false } }} cacheGroups中vendors配置表示将从node_modules中引入的模块统一打包到一个 vendors.js 文件中 splitChunks的vendors的default参数： 根据上下文来解释，如上配置了vendors，打包node_modules文件夹中的模块， 那么default将会打包自己编写的公共方法。 当不使用default配置时。 123 Asset Size Chunks Chunk Namesmain.js 315 KiB main [emitted] maintest.js 315 KiB test [emitted] test 添加如下配置之后： 12345678910111213141516171819optimization: { splitChunks: { chunks: 'all', cacheGroups: { // 下面的意思是：将从node_modules中引入的模块统一打包到一个vendors.js文件中 vendors: { test: /[\\\\/]node_modules[\\\\/]/, priority: -10, filename: 'vendors.js' }, // 打包除上面vendors以外的公共模块 default: { priority: -20, reuseExistingChunks: true, // 如果该chunk已经被打包进其他模块了，这里就复用了，不打包进common.js了 filename: 'common.js' } } }} 打包后的文件体积为 1234 Asset Size Chunks Chunk Namescommon.js 308 KiB default~main~test [emitted] default~main~test main.js 7.03 KiB main [emitted] main test.js 7.02 KiB test [emitted] test 配置说明 12345678910splitChunks: { chunk: 'all', // all(全部)， async(异步的模块)，initial(同步的模块) minSize: 3000, // 表示文件大于3000k的时候才对他进行打包 maxSize: 0, minChunks: 1, // 当某个模块满足minChunks引用次数时，才会被打包。例如,lodash只被一个文件import，那么lodash就不会被code splitting,lodash将会被打包进 被引入的那个文件中。如果满足minChunks引用次数，lodash会被单独抽离出来，打出一个chunk。 maxAsyncRequests: 5, // 在打包某个模块的时候，最多分成5个chunk，多余的会合到最后一个chunk中。这里分析下这个属性过大过小带来的问题。当设置的过大时，模块被拆的太细，造成并发请求太多。影响性能。当设置过小时，比如1，公共模块无法被抽离成公共的chunk。每个打包出来的模块都会有公共chunk automaticNameDelimiter: '~', // 当vendors或者default中的filename不填时，打包出来的文件名就会带~ name: true, cashGroups: {} // 如上} maxAsyncRequests Lazy Loading异步import的包会被单独打成一个chunk 1234567891011async function getComponent() { const { default: _ } = await import(/* webpackChunkNanem:'lodash */ 'lodash'); const element = document.createElement('div'); element.innerHTML = _.join(['Dell', 'Lee'], '-'); return element;}document.addEventListener('click', () =&gt; { getComponent().then(element =&gt; { document.body.appendChild(element); });}); lazy loading chunk每一个js文件都是一个chunk chunk是使用Webpack过程中最重要的几个概念之一。在 Webpack 打包机制中，编译的文件包括 entry（入口，可以是一个或者多个资源合并而成，由 html 通过 script 标签引入）和 chunk（被 entry 所依赖的额外的代码块，同样可以包含一个或者多个文件）。从页面加速的角度来讲，我们应该尽可能将所有的 js 打包到一个 bundle.js 之中，但是总会有一些功能是使用过程中才会用到的。出于性能优化的需要，对于这部分资源我们可以做成按需加载。 打包分析打包分析： 安装：npm install --save-dev webpack-bundle-analyzer 123// package.json =&gt; scripts\"analyz\": \"NODE_ENV=production npm_config_report=true npm run build\" 12345// webpack.config.jsconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer') .BundleAnalyzerPlugin;plugins: [new BundleAnalyzerPlugin()]; 执行命令npm run analyz 浏览器就会自动打开localhost:8888，分析图就会展现在你眼前 非常清晰直观的看出 ![image-20190421142354243](/Users/zhouatie/Library/Application Support/typora-user-images/image-20190421142354243.png) CSS 文件的代码分割我们之前写的 css 文件都会被打包进 js 文件中，要想把 css 单独打包成一个 css 文件该怎么做呢？ 这个时候就需要用到MiniCssExtractPlugin 开发环境用不到这个功能，一般都是用在生产环境中。 安装：npm install --save-dev mini-css-extract-plugin 123456789101112131415161718192021222324252627282930313233343536// webpack.config.jsconst MiniCssExtractPlugin = require('mini-css-extract-plugin')module: { rules: [ { test: /\\.css$/, use: [{ loader: MiniCssExtractPlugin.loader, options: { // 可以在此处指定publicPath // 默认情况下，它在webpackoptions.output中使用publicPath publicPath: '../', // hmr: process.env.NODE_ENV === 'development', }, }, 'css-loader'] } ]},plugins: [ new MiniCssExtractPlugin({ // 与webpackoptions.output中相同选项类似的选项 // 两个选项都是可选的 filename: '[name].css', chunkFilename: '[id].css', }),]// index.jsimport './index.css';console.log('haha')// index.cssbody { background: green;} 这样打包之后，css 会被单独打包成一个 css 文件。 缓存目前为止，我们每次修改内容，打包出去后的文件名都不变。线上环境的文件是有缓存的。所以当你文件名不变的话，更新内容打包上线。有缓存的电脑就无法获取到最新的代码。 这个时候我们就会用到contenthash 我们先记录配置contenthash之前打包的文件名。 123 Asset Size Chunks Chunk Namesindex.html 180 bytes [emitted] main.js 3.81 KiB main [emitted] main 接下来我们来配置下contenthash (就是根据你文件内容生成的 hash 值) 12345// webpack.config.jsoutput: { path: path.resolve(__dirname, '../dist'), filename: '[name][contenthash].js'}, 打包完之后会在main后面接上hash值。 123 Asset Size Chunks Chunk Names index.html 200 bytes [emitted]mainf5faa2d3d1e119256290.js 3.81 KiB main [emitted] main 当你不更新内容重新打包后，contenthash还会维持不变。所以线上用户访问的时候就不会去服务器重新拿取代码，而是从缓存中取文件。 shimming (预置依赖)以jquery为例，代码如下 12345678910// index.jsimport $ from 'jquery';$('body').html('HHAHAH');import func from './test.js';func();// test.jsexport default function func() { $('body').append('&lt;h1&gt;2&lt;/h1&gt;');} 当你不在 test.js 中引入import $ from 'jquery' 那么浏览器访问的时候，会报 test.js:5 Uncaught ReferenceError: $ is not defined 这个时候就需要使用垫片功能 1234567const webpack = require('webpack');plugins: [ new webpack.ProvidePlugin({ $: 'jquery' })]; 当你加上这段代码后，模块在打包的时候，发现你使用了$就会在你模块顶部自动加入import $ from 'jquery' 其他关于shimming的内容参考webpack官网 shimming","link":"/blog/2019/05/15/webpack4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"webpack4学习笔记（三）","text":"前言这是我花了几个星期学习 webpack4 的学习笔记。内容不够细，因为一些相对比较简单的，就随意带过了。希望文章能给大家带来帮助。如有错误，希望及时指出。例子都在learn-webpack仓库上。如果你从中有所收获的话，希望你能给我的github点个star。 library当你要开发第三方库供别人使用时，就需要用到library和libraryTarget这两个配置了。 library 12345output: { filename: 'library.js', library: 'library', libraryTarget: 'umd'}, library: 当配置了这个library参数后，会把library这个key对应的value即上面代码library挂载到全局作用域中。html用script标签引入，可以通过访问全局变量library访问到我们自己开发的库。 libraryTarget:这个默认值为var。意思就是让 library 定义的变量挂载到全局作用域下。当然还有浏览器环境的window,node环境的global,umd等。当设置了window、global,library就会挂载到这两个对象上。当配置了umd后，你就可以通过import,require等方式引入了。 externals exterals是开发公共库很重要的一个配置。当你的公共库引入了第三方库的时候，公共库会把该第三方库也打包进你的模块里。当使用者也引入了这个第三方库后，这个时候打包就会又打了一份第三方库进来。 所在在公共模块库中配置如下代码 12345externals: { // 前面的lodash是我的库里引入的包名 比如 import _ from 'lodash' // 后面的lodash是别人业务代码需要注入到他自己模块的lodash 比如 import lodash from 'lodash',注意不能import _ from 'lodash',因为配置项写了lodash 就不能import _ lodash: 'lodash'}, 前面的lodash是我的库里引入的包名 比如import _ from 'lodash',后面的lodash是别人业务代码需要注入到他自己模块的lodash 比如 import lodash from 'lodash',注意不能import _ from 'lodash',因为配置项写了lodash 就不能import _。 本人做了个试验，当自己开发的包不引入lodash,业务代码中也不引入lodash,那么打包业务代码的时候，webpack会把lodash打进你业务代码包里。 当然externals,配置还有多种写法，如下 123456789101112externals: { lodash: { commonjs: 'lodash', commonjs2: 'lodash', amd: 'lodash', root: '_' }}externals: ['lodash', 'jquery']externals: 'lodash' 具体请参考官网externals 发布自己开发的 npm 包学了上面的配置后，就需要学习下如何将自己的包发布到npm仓库上了。 package.json 的入口要改成dist目录下的 js 文件如： &quot;main&quot;: &quot;./dist/library.js&quot; 注册 npm 账号。npm 会发送一份邮件到你的邮箱上，点击下里面的链接进行激活。 命令行输入npm login 进行登录，或者npm adduser 添加账号 npm publish 当出现如下提示代表发布成功 123// 当出现类似如下代码时，表示你已经发布成功➜ library git:(master) ✗ npm publish+ atie-first-module-library@1.0.0 遇到的问题： 当你遇到npm ERR! you must verify your email before publishing a new package说明你还没有激活你的邮箱，去邮箱里点击下链接激活下就 ok 了 当你已经登录了提醒npm ERR! 404 unauthorized Login first,这个时候你就要注意下你的npm源了，看看是否设置了淘宝源等。记得设置回来npm config set registry https://registry.npmjs.org/ PWAhttp-server workbox-webpack-plugin 相信很多朋友都有耳闻过PWA这门技术,PWA是Progressive Web App的英文缩写， 翻译过来就是渐进式增强 WEB 应用， 是 Google 在 2016 年提出的概念，2017 年落地的 web 技术。目的就是在移动端利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验的渐进式网页应用。 优点： 可靠 即使在不稳定的网络环境下，也能瞬间加载并展现 快 快速响应，并且 动画平滑流畅 应用场景： 当你访问正常运行的服务器页面的时候，页面正常加载。可当你服务器挂了的时候，页面就无法正常加载了。 这个时候就需要使用到 pwa 技术了。 这里我编写最简单的代码重现下场景： 12345678910111213141516171819202122232425262728293031323334353637383940// webpack.config.jsconst HtmlWebpackPlugin = require('html-webpack-plugin')const CleanWebpackPlugin = require('clean-webpack-plugin')module.exports = { mode: 'production', entry: './index.js', output: { filename: 'bundle.js' }, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin() ]}// index.jsconsole.log('this is outer console')// package.json{ \"name\": \"PWA\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"build\": \"webpack --config webpack.config.js\", \"start\": \"http-server ./dist\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"clean-webpack-plugin\": \"^2.0.1\", \"html-webpack-plugin\": \"^3.2.0\", \"http-server\": \"^0.11.1\", \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.1\", }} 执行下npm run build 123.├── bundle.js└── index.html 为了模拟服务器环境，我们安装下http-server npm i http-server -D 配置下package.json，&quot;start&quot;: &quot;http-server ./dist&quot; 执行npm run start来启动 dist 文件夹下的页面 这个时候控制台会正常打印出'this is outer console' 当我们断开http-server服务后，在访问该页面时，页面就报 404 了 这个时候就需要使用到 pwa 技术了 使用步骤： 安装： npm i workbox-webpack-plugin -D webpack 配置文件配置： 1234567891011121314151617181920// webpack.config.jsconst { GenerateSW } = require('workbox-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = { mode: 'production', entry: './index.js', output: { filename: 'bundle.js' }, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(), new GenerateSW({ skipWaiting: true, // 强制等待中的 Service Worker 被激活 clientsClaim: true // Service Worker 被激活后使其立即获得页面控制权 }) ]}; 这里我们写一个最简单的业务代码，在注册完 pwa 之后打印下内容： 1234567891011121314151617// index.jsconsole.log('this is outer console');// 进行 service-wroker 注册if ('serviceWorker' in navigator) { window.addEventListener('load', () =&gt; { navigator.serviceWorker .register('./service-worker.js') .then(registration =&gt; { console.log('====== this is inner console ======'); console.log('SW registered: ', registration); }) .catch(registrationError =&gt; { console.log('SW registration failed: ', registrationError); }); });} 执行下打包命令：npm run build 12345.├── bundle.js├── index.html├── precache-manifest.e21ef01e9492a8310f54438fcd8b1aad.js└── service-worker.js 打包之后会生成个service-worker.js与precache-manifest.e21ef01e9492a8310f54438fcd8b1aad.js 接下来再重启下http-server服务：npm run start 页面将会打印出 123this is outer console====== this is inner console ======... 然后我们再断开http-server服务 刷新下页面，竟然打印出了相同的代码。说明 pwa 离线缓存成功。 typescript使用 webpack 打包 ts 文件，就需要安装ts-loader 安装：npm i ts-loader typescript -D webpack.config.js文件中添加解析typescript代码的loader 1234567891011121314151617181920const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = { mode: 'production', entry: './src/index.ts', output: { filename: 'bundle.js' }, module: { rules: [ { test: /\\.ts$/, loader: 'ts-loader', exclude: /node_modules/ } ] }, plugins: [new CleanWebpackPlugin(), new HtmlWebpackPlugin()]}; 配置了webpack.config.js还不行，还得在根目录文件下新增个.tsconfig.json文件 123456789{ \"compilerOptions\": { \"outDir\": \"./dist/\", // 默认解析后的文件输出位置 \"noImplicitAny\": true, // 存在隐式 any 时抛错 \"module\": \"es6\", // 表示这是一个es6模块机制 \"target\": \"es5\", // 表示要讲ts代码转成es5代码 \"allowJs\": true // 表示允许引入js文件。TS 文件指拓展名为 .ts、.tsx 或 .d.ts 的文件。如果开启了 allowJs 选项，那 .js 和 .jsx 文件也属于 TS 文件 }} 新建index.ts 12345678910111213141516171819class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return 'Hello, ' + this.greeting; }}let greeter = new Greeter('world');let button = document.createElement('button');button.textContent = 'Say Hello';button.onclick = function() { alert(greeter.greet());};document.body.appendChild(button); 执行打包命令，访问打包后的页面，页面正常执行。 当需要使用lodash等库时， 需安装：npm i @types/lodash -D 修改页面代码 引入 lodash 123456789101112131415161718192021import * as _ from 'lodash';class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return 'Hello, ' + this.greeting; }}let greeter = new Greeter('world');let button = document.createElement('button');button.textContent = 'Say Hello';button.onclick = function() { alert(_.join(['lodash', greeter.greet()], '-'));};document.body.appendChild(button); 提醒：ts 使用的包，可通过https://microsoft.github.io/TypeSearch 这个网址去查对应的包使用指南 使用WebpackDevServer实现请求转发当我们工作本地开发某一个需求的时候，需要将这块需求的请求地址转发到某个后端同事的本地服务器或某个服务器上，就需要用到代理。然后其他页面的请求都走测试环境的请求。那么我们该怎样拦截某个请求，并将其转发到我们想要转发的接口上呢？ 这个时候就需要用到webpack-dev-server 主要看devServer配置： 1234567891011121314151617// webpack.config.jsconst CleanWebpackPlugin = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { mode: 'development', entry: './index.js', output: { filename: 'bundle.js' }, devServer: { contentBase: './dist', open: true, hot: true }, plugins: [new HtmlWebpackPlugin(), new CleanWebpackPlugin()]}; 12345// package.jsonscripts: { \"server\": \"webpack-dev-server\"} 12345678910111213// index.jsimport axios from 'axios';const div = document.createElement('div');div.innerHTML = 'hahahha';div.addEventListener('click', () =&gt; { alert('hahah'); axios.get('/list').then(res =&gt; { console.log(res); });});document.body.appendChild(div); 在写一个本地启动的服务端代码 123456789101112const express = require('express');const app = express();app.get('/api/list', (req, res) =&gt; { res.json({ success: true });});app.listen(8888, () =&gt; { console.log('listening localhost:8888');}); 执行npm run server命令，浏览器会自动打开页面。点击 div 后，会发起请求。 浏览器提示http://localhost:8080/api/list 404 (Not Found),表示该接口不存在。 因为我们webpack启动静态资源服务器默认端口为 8080，所以他求会直接请求到 8080 的/api/list 接口。所以会提示找不到该接口。 为了解决这个问题，我们就需要将该请求从 8080 端口代理到 8888 端口(也就是我们自己本地启动的服务) 配置webpack.config.js 这里我只展示devServer代码 1234567891011// webpack.config.jsdevServer: { contentBase: './dist', open: true, hot: true, proxy: { '/api': { target: 'http://localhost:8888' } }}, 配置devServer的proxy字段的参数，将请求/api开头的请求都转发到http://localhost:8888, 通过这个方法可以解决一开始提到的本地开发的时候，只想把部分接口转发到某台部署新需求的服务器上。比如当你这个项目请求很多，不同接口部署在不同的端口或者不同的服务器上。那么就可以通过配置第一个路径，来区分不同的模块。并转发到不同的服务上。如： 1234567891011121314151617// webpack.config.jsdevServer: { contentBase: './dist', open: true, hot: true, proxy: { '/module1': { target: 'http://localhost:8887' }, '/module2': { target: 'http://localhost:8888' }, '/module3': { target: 'http://localhost:8889' } }}, 当你要代理到某个 https 的接口上，就需要设置secure: false 123456789// webpack.config.jsdevServer: { proxy: { '/api': { target: 'https://other-server.example.com', secure: false } }} 12345678target: ''， // 代理的目标地址secure: false, // 请求https的需要设置changeOrigin: true, // 跨域的时候需要设置headers: { host: 'http://www.baidu.com', //修改请求域名 cookie: ''}... 其他关于devServer的配置详见devServer WebpackDevServer 解决单页面路由 404 问题相信大家都是开发过 vue 或者 react 单页面带路由的应用。这里就忽略业务代码，介绍下devServer的historyApiFallback参数 123devServer: { historyApiFallback: true, // 当设置为true时，切换路由就不会出现路由404的问题了} 详见historyApiFallback eslint安装eslint: npm i eslint -D 目录下新建.eslintrc.json文件。 environment: 指定脚本的运行环境 globals: 脚本在执行期间访问的额外全局变量。 rules: 启动的规则及其各自的错误级别。 解析器选项: 解析器选项 编辑你的eslint的规则 123456789101112{ \"parserOptions\": { \"ecmaVersion\": 6, \"sourceType\": \"module\", \"ecmaFeatures\": { \"jsx\": true } }, \"rules\": { \"semi\": 2 }} vscode安装eslint插件。 配置下webpack.config.js配置。 123456789101112131415...devServer: { overlay: true, contentBase: './dist', hot: true, open: true},module: { rules: [{ test: /\\.js$/, exclude: /node_modules/, use: ['eslint-loader'] }]}... eslint-loader是用于检查js代码是否符合eslint规则。 这里devServer中的overlay的作用是，当你 eslint 报错的时候，页面会有个报错蒙层。这样就不局限于编辑器（vscode)的报错提醒了。 如果 js 代码使用了多个 loader，那么 eslint-loader 一定要写在最右边。如果不写在最后一个的话，需在里面添加enforce: &quot;pre&quot;,这样不管写在哪个位置都会优先使用eslint-loader校验下代码规范。 123456{ loader: 'eslint-loader', options: { enforce: \"pre\", }} 提升webpack打包速度的方法1. 跟上技术的迭代 升级webpack版本 node版本npm等版本 2. 尽可能少的模块上应用loader include exclude 3. 尽可能少的使用plugin4. resolve123456resolve: { extensions: ['.js'], alias: { 'src': path.resolve(__dirname, '../src') }} extensions: 可以让你 import 模块的时候不写格式，当你不写格式的时候，webpack 会默认通过 extensions 中的格式去相应的文件夹中找 alias:当你import的路径很长的时候，最好使用别名，能简化你的路径。 比如：import index.js from '../src/a/b/c/index.js' 设置别名： 12345resolve: { alias: { '@c': path.resolve(__dirname, '../src/a/b/c') }} 这样你的import导入代码就可以改成import index.js from '@c/index.js' 5. dllPlugin我们先记录下不使用dll打包时间787ms： 12345Time: 787msBuilt at: 2019-05-04 18:32:29 Asset Size Chunks Chunk Names bundle.js 861 KiB main [emitted] mainindex.html 396 bytes [emitted] 接下来我们就尝试使用dll技术 我们先配置一个用于打包dll文件的webpack配置文件，生成打包后的js文件与描述动态链接库的manifest.json 123456789101112131415161718192021// webpack.dll.config.jsconst path = require('path');const webpack = require('webpack');module.exports = { entry: { vendor: ['jquery', 'lodash'] // 要打包进vendor的第三方库 }, output: { filename: '[name].dll.js', // 打包后的文件名 path: path.resolve(__dirname, './dll'), // 打包后存储的位置 library: '[name]_[hash]' // 挂载到全局变量的变量名，这里要注意 这里的library一定要与DllPlugin中的name一致 }, plugins: [ new webpack.DllPlugin({ // 用于打包出一个个单独的动态链接库文件 name: '[name]_[hash]', // 引用output打包出的模块变量名，切记这里必须与output.library一致 path: path.join(__dirname, './dll', '[name].manifest.json') // 描述动态链接库的 manifest.json 文件输出时的文件名称 }) ]}; 重点：这里引入的 DllPlugin 插件，该插件将生成一个 manifest.json 文件，该文件供 webpack.config.js 中加入的 DllReferencePlugin 使用，使我们所编写的源文件能正确地访问到我们所需要的静态资源（运行时依赖包）。 配置下package.json文件的scripts: &quot;build:dll&quot;: &quot;webpack --config webpack.dll.config.js&quot; 执行下 npm run build:dll 1234Time: 548msBuilt at: 2019-05-04 18:54:09 Asset Size Chunks Chunk Namesvendor.dll.js 157 KiB 0 [emitted] vendor 除了打包出dll文件之外，还得再主webpack配置文件中引入。这里就需要使用到DllReferencePlugin。具体配置如下： 1234// webpack.config.jsnew webpack.DllReferencePlugin({ manifest: require('./dll/vendor.manifest.json')}), 这里的manifest：需要配置的是你dllPlugin打包出来的manifest.json文件。让主webpack配置文件通过这个 描述动态链接库manifest.json文件，让js导入该模块的时候，直接引用dll文件夹中打包好的模块。 看似都配置好了，接下来执行下命令 npm run build 使用dll打包后时间： 12345Time: 471msBuilt at: 2019-05-04 18:19:49 Asset Size Chunks Chunk Names bundle.js 6.43 KiB main [emitted] mainindex.html 182 bytes [emitted] 直接从最开始的787ms降低到471ms，当你抽离的第三方模块越多，这个效果就越明显。 浏览器跑下html页面，会报错 Uncaught ReferenceError: vendor_e406fbc5b0a0acb4f4e9 is not defined 这是因为index.html还需要通过script标签引入这个dll打包出来的js文件 我们如果每次自己手动引入的话会比较麻烦，如果dll文件非常多的话，就难以想象了。 这个时候就需要借助add-asset-html-webpack-plugin这个包了。 12345const AddAssetHtmlPlugin = require('add-asset-html-webpack-plugin');new AddAssetHtmlPlugin({ filepath: path.resolve(__dirname, './dll/vendor.dll.js')}); 通过这包，webpack会将dll打包出来的js文件通过script标签引入到index.html文件中 这个时候你在npm run build，访问下页面就正常了 6. 控制包文件大小tree-shaking 等 7. thread-loader parallel-webpack happypack 等多进程打包8. 合理使用 sourceMap9. 结合 stats 分析打包结果借助线上或者本地打包分析工具 10. 开发环境内存编译开发环境的时候不会生成 dist 文件夹，会直接从内存中读取，因为内存读取比硬盘读取快 11. 开发环境无用插件剔除F","link":"/blog/2019/05/15/webpack4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"},{"title":"webpack4学习笔记（四）","text":"前言这是我花了几个星期学习 webpack4 的学习笔记。内容不够细，因为一些相对比较简单的，就随意带过了。希望文章能给大家带来帮助。如有错误，希望及时指出。例子都在learn-webpack仓库上。如果你从中有所收获的话，希望你能给我的github点个star。 编写 loader12// index.jsconsole.log('hello, atie'); 配置webpack.config.js 1234567891011// webpack.config.jsmodule: { rules: [ { test: /\\.js$/, include: /src/, loader: path.resolve(__dirname, './loaders/replaceLoader.js') } ]}, 12345// 函数不能使用箭头函数module.exports = function(source) { console.log(source, 'source'); return source.replace('atie', 'world');}; loader文件其实就是导出一个函数，source就是webpack打包出的js字符串。这里的loader就是将上面的console.log('hello, atie')替换为console.log('hello, world') 打包下代码，不出所料。控制台就会打印出hello, world 当你想要给 loader 传参时，可配置如下 1234567891011121314module: { rules: [ { test: /\\.js$/, include: /src/, use: [{ loader: path.resolve(__dirname, './loaders/replaceLoader.js'), options: { name: 'haha' } }] } ]}, 通过给loader添加options 这样loader中就可以通过this.query获取该参数了 12345module.exports = function(source) { // 控制台输出：console.log('hello atie') { name: 'haha' } source console.log(source, this.query, 'source'); return source.replace('atie', 'world');}; 当然变量不一定非要通过this.query来获取 可通过loader-utils这个包来获取传入的变量 安装: npm i loader-utils -D 123456789const loaderUtils = require('loader-utils');// 函数不能使用箭头函数module.exports = function(source) { // console.log(source, this.query, 'source') const options = loaderUtils.getOptions(this); console.log(options, 'options'); // { name: 'haha' } 'options' return source.replace('atie', 'world');}; 打印出来的与上面this.query一致 上面都是直接通过return返回的，那么我们还有没有其他方法返回loader翻译后的代码呢？` 这里就会用到callback 123456this.callback( err: Error | null, content: string | Buffer, sourceMap?: SourceMap, meta?: any); 上面的代码就可以改写成 12345module.exports = function(source) { const options = loaderUtils.getOptions(this); const result = source.replace('atie', options.name); this.callback(null, result);}; callback优势在于它可以传递多余的参数 12345module.exports = function(source) { setTimeout(() =&gt; { return source.replace('atie', 'world'); }, 1000);}; 当我们把return包到异步方法里，打包的时候就会报错，那么我们该怎么办呢？ 这个时候就需要用到this.async() 123456module.exports = function(source) { const callback = this.async(); setTimeout(() =&gt; { callback(null, source.replace('atie', 'world')); }, 2000);}; 通过调用this.async()返回的callback方法来返回结果 use 中的 loader 执行顺序，先右后左，先下后上 编写 plugin在根目录下新建plugins文件夹，并新建copyright-webpack-plugin.js，内容如下： 1234567class Copyright { constructor() { console.log('this is plugin'); } apply(compiler) {}}module.exports = Copyright; 注意：apply 这个方法必须存在，不然插件被执行的时候会报错。 配置webpack.config.js,如下： 1234567const Copyrgiht = require('./plugins/copyright-webpack-plugin.js')...plugins: [ new Copyrgiht()] 执行下打包命令后 12345678this is pluginHash: 479baeba2207182096f8Version: webpack 4.30.0Time: 615msBuilt at: 2019-05-08 23:05:08 Asset Size Chunks Chunk Names bundle.js 3.77 KiB main [emitted] mainindex.html 182 bytes [emitted] 控制台打印出了this is plugin 接下来，我们继续探索插件的奥秘 在使用插件的时候还可以传参 123456// webpack.config.jsplugins: [ new Copyrgiht({ name: 'atie' })]; 123456789class Copyright { constructor(options) { // console.log(options, 'this is plugin') this.options = options; } apply(compiler) { console.log(this.options); }} 执行下打包命令： 12345678{ name: 'atie' }Hash: 479baeba2207182096f8Version: webpack 4.30.0Time: 742msBuilt at: 2019-05-08 23:24:10 Asset Size Chunks Chunk Names bundle.js 3.77 KiB main [emitted] mainindex.html 182 bytes [emitted] 控制就会输出 {name: 'atie'} webpack在调用apply会传递一个compiler参数，这个参数可以做很多事情，具体可以参考webpack官网 这里介绍下钩子 123456789101112131415161718class Copyright { apply(compiler) { compiler.hooks.emit.tapAsync('Copyright', (compilation, callback) =&gt; { console.log(compilation.assets, '以具有延迟的异步方式触及 run 钩子。'); compilation.assets['copyright.txt'] = { source: function() { return 'copyright by atie'; }, size: function() { return 17; } }; callback(); }); }}module.exports = Copyright; 该钩子是在文件生成前触发的。我们在文件生成前，在asset对象上在加一个文件对象 打包之后 1234.├── bundle.js├── copyright.txt└── index.html 可以看到多了一个copyright.txt，也就是我们上面创建的文件。点开该文件还会看到里面的内容正是copyright by atie","link":"/blog/2019/05/15/webpack4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"},{"title":"docker从入门到实战-基础篇","text":"前言本文是我通过三个星期业余时间学习后而写的文章，对 docker 的了解还处于入门阶段。希望本文能帮忙一些想学习 docker 的朋友快速入门。练习及实战代码都在 github 仓库中。如果我的文章能帮助到你的话，可以给我的docker 项目点个赞哦 介绍docker 是一个开源的应用容器引擎，开发者可以打包自己的应用到容器里面，然后迁移到其他机器的 docker 应用中，可以实现快速部署。如果出现的故障，可以通过镜像，快速恢复服务。 举个例子，公司一般都会有多套环境，那么如何保持多套的运行环境一致，这个时候就可以用到 docker。且当要求增加一套环境的时候，你无需在一个新服务器上一个个环境安装、配置。只需要运行下 docker。同时官方还提供了Docker Hub，拥有大量的高质量的官方镜像。你可以将自己的镜像上传上去。有点类似于github。 安装官方提供了安装教程，挺详细的。官方安装教程 docker 起步第一步：执行下docker -v确认下是否成功安装了 docker 如果成功安装了，命令行将会输出入 docker 的版本号。如下：Docker version 18.09.2, build 6247962 docker 的整个生命周期大致可分为： 镜像 容器 仓库 这里以ubuntu镜像为例，介绍下镜像 在下载ubuntu镜像之前运行下docker images(查看镜像命令)查看下本地的镜像。如果你还没下载过镜像的话，当然会出现空。这里贴下我本地的镜像 12345678➜ study-docker git:(master) ✗ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtodolist_static latest de5e325037e9 2 hours ago 1.05GBtodolist_nodejs latest 53efd80e03e1 2 hours ago 898MBubuntu 18.04 7698f282e524 4 weeks ago 69.9MBmysql latest 990386cbd5c0 5 weeks ago 443MBnode 8 a5c31320f223 6 weeks ago 895MBmysql 5.6 73829d7b6139 6 weeks ago 256MB 使用拉取镜像命令docker pull 拉取ubuntu镜像：docker pull ubuntu。当你不指定版本时，默认拉取 latest 版本。 123456789101112➜ study-docker git:(master) ✗ docker pull ubuntuUsing default tag: latestlatest: Pulling from library/ubuntu5b7339215d1d: Pull complete14ca88e9f672: Pull completea31c3b1caad4: Pull completeb054a26005b7: Pull completeDigest: sha256:9b1702dcfe32c873a770a32cfd306dd7fc1c4fd134adfb783db68defc8894b3cStatus: Downloaded newer image for ubuntu:latest➜ study-docker git:(master) ✗ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu latest 4c108a37151f 12 hours ago 64.2MB 也可安装指定版本镜像：docker pull ubuntu:18.04 接下来基于ubuntu镜像启动一个容器 docker run --name first -it ubuntu bash –name 用于指定容器名 it 用于交互式命令行操作，如下面例子运行后，会打开容器的命令行 上面的 ubuntu 指的镜像，默认基于 latest。除非指定版本 如 ubuntu:18.04 运行上面的命令后，命令行工具就会自动进入容器的命令行。如果想要退出该命令行界面，可输入exit以退出。 12➜ study-docker git:(master) ✗ docker run --name first -it ubuntu bashroot@b7862a018c2c:/# 如果想让该容器在后台运行可以通过加-d配置来让该容器在后台运行。后台运行，命令行工具不会进入该容器。 使用docker ps查看当前运行中的容器。 123➜ study-docker git:(master) ✗ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMEScf8375f48225 ubuntu \"bash\" 15 seconds ago Up 14 seconds first 使用-d来让容器在后台运行 12➜ study-docker git:(master) ✗ docker run --name first -itd ubuntu bash6df29a09d1f1bb0041b7eb59b5288162471ed8a663007f88c6a30e3fd1f4fbe2 命令行会返回容器 id 使用docker container ls 查看所有容器列表（不包括停止运行的容器） 123➜ study-docker git:(master) ✗ docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMEScf8375f48225 ubuntu \"bash\" About a minute ago Up About a minute first 使用docker stop &lt;容器id或容器名称&gt;停止容器的运行。 12➜ study-docker git:(master) ✗ docker stop 6df29a09d1f16df29a09d1f1 执行命令后，会返回你刚输入容器的 id。上面的容器 id 不需要填全。就想 git 的 commit id 一样。 这个时候通过docker container ls是查不到容器信息的。需要用docker container ls -a来查看。 123➜ study-docker git:(master) ✗ docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6df29a09d1f1 ubuntu \"bash\" 5 minutes ago Exited (0) 4 minutes ago 可以看到 STATUS 一栏处，该容器是处于停止状态的。 使用docker rm &lt;容器id 或者 容器昵称&gt; 123➜ node git:(master) docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa217eea7188f ubuntu \"/bin/bash\" 11 seconds ago Exited (0) 10 seconds ago dreamy_ishizaka 执行docker rm a21 (id 可以不输全) 12➜ node git:(master) docker rm a21a21 执行完之后，命令行会返回之前输入的容器 id 使用docker container prune，来清空停用状态的容器。 使用docker exec命令进入运行中的容器 如想进入刚才后台运行的容器的交互式界面:docker exec -it &lt;容器名称 或者 容器id&gt; bash 12➜ study-docker git:(master) ✗ docker exec -it first bashroot@2a87b2f62a6e:/# 想查看更多关于 docker 的命令，点击这里 Dockerfile举个node镜像的例子 新建一个文件夹 我这里就新建一个名为 node 的文件夹，具体文件可参照我的 github 项目的node 目录 1234567// index.jsconst express = require('express');const app = express();app.get('/', (req, res) =&gt; { res.end('success');});app.listen(6001); 123456// DockerfileFROM node:8WORKDIR /home/nodeCOPY ../ ../RUN npm installCMD npm start 指令介绍 FROM 我这个 node 例子是基于 node8 镜像 WORKDIR 指定工作区。 COPY 将本地目录文件拷贝到 docker 中 RUN 运行一个容器，每个 RUN 都会生成一个容器 CMD 执行命令，与 RUN 相似 注意 有必要添加.dockerignore 文件，文件中可以填写你不想打包进容器的文件。类似于.gitignore 123// .dockerignore/node_modulespackage-lock.json 详细解释，详见dockerfile docker build 命令用于使用 Dockerfile 创建镜像 执行：docker build -t mynode .; -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。tag 不写默认为 latest 版本要注意后面的. 这个表示 Dockerfile 文件在当前目录。构建镜像成功之后： 123➜ node git:(master) ✗ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmynode latest 3cd10521f802 10 hours ago 898MB 接下来就基于该镜像运行一个 node 容器: docker run --name mynode -p 4001:6001 mynode –name: 表示该容器的匿名 -p: 表示端口映射，因为主机的 ip 跟容器的 ip 是不同的，需要把容器的服务映射到 0.0.0.0:自己设置的主机端口，host 不填默认为 0.0.0.0。 &lt;主机端口&gt;:&lt;容器中端口&gt;； 123➜ node git:(master) ✗ docker run --name mynode -p 4001:6001 mynode&gt; example2@1.0.0 start /home/node&gt; node index.js 浏览器访问localhost:4001,页面会展示出 node 响应的success字符串了。 构建完镜像后，你觉得不需要该镜像，想删除怎么办呢？ 首先执行：docker images列出镜像列表 123➜ node git:(master) ✗ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmynode latest 3cd10521f802 10 hours ago 898MB 使用docker rmi &lt;image id&gt;来删除镜像：docker rmi 3cd10521f802,如果提醒该镜像被容器占用着，那么你就需要先删除该容器(参考上面介绍的命令)。","link":"/blog/2019/07/07/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98-%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"title":"docker从入门到实战-实战篇","text":"前言本文是我通过三个星期业余时间学习后而写的文章，对 docker 的了解还处于入门阶段。希望本文能帮忙一些想学习 docker 的朋友快速入门。练习及实战代码都在 github 仓库中。如果我的文章能帮助到你的话，可以给我的docker 项目点个赞哦 docker 实战本次实战案例是 todolist。技术栈为 vue、node、mysql。具体代码见项目目录todolist,下面就不一一贴代码了。就讲下重点。 下面我就顺着依赖关系来讲，所以先从 mysql 开始讲起 构建 mysql执行：docker run --name mymysql -d -p 3308:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql –name 给 mysql 容器设置匿名 -d 表示后台运行 -p 表示将容器的 3306 端口的映射到本地的 3308 端口，如果不设置的话，本地是无法访问该 MySQL 服务的。 -e MYSQL_ROOT_PASSWORD 设置 root 的账号密码。 mysql 后面不指定版本话，默认会 latest 版本 在执行该语句之前，假如你之前没有 pull 过 mysql 镜像。docker 在本地找不到你要的镜像就会帮你从 docker 仓库拉取 mysql:latest 镜像。 这个时候容器就启动成功了。 尝试下用 navicat 连接下试试 鼠标放入黄色小三角出现如下报错。 12013 - Lost connection to MySQL server at 'reading initial communication packet', system error: 0 \"Internal error/check (Not system error)\" 这是因为 mysql8 以上，都会使用新的验证方式。 不妨查下信息: select host,user,plugin,authentication_string from mysql.user; 12345678910mysql&gt; select host,user,plugin,authentication_string from mysql.user;+-----------+------------------+-----------------------+------------------------------------------------------------------------+| host | user | plugin | authentication_string |+-----------+------------------+-----------------------+------------------------------------------------------------------------+| % | root | caching_sha2_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 || localhost | mysql.infoschema | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED || localhost | mysql.session | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED || localhost | mysql.sys | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |)7k44VulAglQJgGpvgSG.ylA/rdbkqWjiqQJiq3DGsug5HIy3 |ord | $A$005$0pU+sGm[on+-----------+------------------+-----------------------+------------------------------------------------------------------------+ plugin 一栏可看到都是 caching_sha2_password。 那么如何才能将其改成可连接的呢？只需要将其 plugin 改成 mysql_native_password 就可以访问了。 ALTER user 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456'; 你可以先用上面查询账户信息查下是否修改成功了。 修改成功后，可以尝试下用 navicat 连接下 mysql。不出意外的话就能成功连接上了。 当然我下面的例子用 mysql:5.6，方便操作，不需要修改 plugin。 执行命令：docker run --name mymysql -d -e MYSQL_ROOT_PASSWORD=123456 -p 3308:3306 mysql:5.6 启动容器后可以执行：docker exec -it mymysql bash进入容器 执行：mysql -uroot -p123456进入 mysql 控制台 执行：show databases;查看 mysql 数据库 123456789mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.00 sec) 执行：create database todolist;创建 todolist 应用的数据库 执行：show databases;查看刚刚创建的 todolist 数据库 12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || todolist |+--------------------+4 rows in set (0.00 sec) 可以看到数据库中多了个 todolist 数据库 接下来选择该 todolist 数据库 执行：use todolist;选中该数据库 创建表: 12345CREATE TABLE list ( id INT(11) AUTO_INCREMENT PRIMARY KEY, text VARCHAR(255), checked INT(11) DEFAULT 0 ); 执行：show tables;查看 todolist 数据库下的表 1234567mysql&gt; show tables;+--------------------+| Tables_in_todolist |+--------------------+| list |+--------------------+1 row in set (0.00 sec) 执行：describe list;查看表 123456789mysql&gt; describe list;+---------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+---------+--------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || text | varchar(255) | YES | | NULL | || checked | int(11) | YES | | 0 | |+---------+--------------+------+-----+---------+----------------+3 rows in set (0.01 sec) 执行：insert into list set checked = 0, text = 'haha'; 往表中插入一条数据； 执行：select * from list; 1234567mysql&gt; select * from list;+----+------+---------+| id | text | checked |+----+------+---------+| 1 | haha | 0 |+----+------+---------+1 row in set (0.01 sec) 一切正常 构建 nodemysql 服务启动好了，接下来就是启动 node 服务，并连接刚启动的 mysql 服务了。 话不多说，直接上代码，解释看注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// index.jsconst mysql = require('mysql'); // mysql包const express = require('express');const app = express();const bodyParser = require('body-parser'); // post请求需要引入的包app.use(bodyParser.json());// mysql配置（用于连接刚启动的mysql服务）const opt = { host: 'localhost', user: 'root', port: '3308', password: '123456', database: 'todolist'};const connection = mysql.createConnection(opt);const sqlFn = sql =&gt; { return new Promise((resolve, reject) =&gt; { connection.query(sql, (err, results, filelds) =&gt; { if (err) throw err; resolve(results); }); });};connection.connect(async err =&gt; { if (err) throw err; console.log('mysql connncted success!');});// todolist 列表查询app.get('/getList', async (req, res) =&gt; { const sql = `SELECT * FROM list`; const data = await sqlFn(sql); res.json({ code: 0, data, message: 'success' });});// todolist 插入数据app.post('/insert', async (req, res) =&gt; { const sql = `INSERT INTO list SET checked = ${req.body.checked}, text = '${req.body.text}'`; const data = await sqlFn(sql); res.json({ code: 0, data, message: 'success' });});app.listen(3000); 执行: node index.js后，控制台输入 12➜ server git:(master) ✗ node index.jsmysql connncted success! 表示 node 服务连接 mysql 服务成功； 浏览器可以访问下localhost:3000/getList 1{\"code\":0,\"data\":[{\"id\":1,\"text\":\"haha\",\"checked\":0}],\"message\":\"success\"} 页面将会出现刚才我们 sql 插入到数据库的数据 既然代码没有问题，那么我们接下来就把他构建成镜像。 构建之前需要把代码中 opt 的 host localhost 改为自己主机的 ip。因为容器启动的话，连接 mysql 需要通过主机的 3308 端口访问。 在当前文件夹新建名为 Dockerfile 的文件 12345678910# 基于最新的 node 镜像FROM node:8# 复制当前目录下所有文件到目标镜像 /app/ 目录下COPY . /todolist/server# 修改工作目录WORKDIR /todolist/server# 安装依赖RUN [\"npm\", \"install\"]# 启动 node serverENTRYPOINT [\"node\", \"index.js\"] 执行：docker build -t mynode .，生成 node 镜像 -t:表示给该镜像添加版本，这里不写默认为 latest 可通过docker images查看本地的镜像。 123➜ server git:(master) ✗ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmynode latest 3e8de2825063 4 seconds ago 898MB 可以看到第一个镜像就是我们刚刚构建的镜像 123➜ server git:(master) ✗ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmynode latest 3e8de2825063 4 seconds ago 898MB 接下来运行基于这个镜像的容器 执行：docker run --name mynode -d -p 4000:3000 mynode –name 给 node 容器起一个容器匿名 -d 表示后台运行 -p 4000:3000 表示访问本地 4000 代理容器内的 3000 端口服务 mynode 是上面我们 build 构建的镜像 启动成功后，访问下localhost:4000/getList 1{\"code\":0,\"data\":[{\"id\":1,\"text\":\"haha\",\"checked\":0}],\"message\":\"success\"} 可以看到页面输出我们上面执行 sql 语句插入的数据 上面贴的代码只是基础的查看列表与插入数据两个方法，其他的请参考server 构建 vuetodolist 的静态页面，我是通过 vue-cli3 搭建的。执行vue create app 创建项目。 进入项目根目录执行npm run serve页面是否正常执行。 然后编写简易的具有增删改查的 todolist 应用。具体代码见todolist。 注意 vue.config.js 中的 devServer 配置的 target: ‘http://127.0.0.1:4000'代理到我们刚启动的node容器 页面启动成功后，访问localhost:8080 可以看到页面加载成功，列表也成功渲染出上面构建 mysql 时，sql 插入的数据。 本地启动静态并请求服务端成功后，接下来也将静态页面打包成镜像，然后启动静态页面容器 在打包镜像容器之前，记得先将 vue.config.js 中的 devServer 配置的 target: ‘http://&lt;主机 ip 地址&gt;:4000’代理到我们刚启动的 node 容器 编写 Dockerfile 12345678910# 基于最新的 node 镜像FROM node:8# 复制当前目录下所有文件到目标镜像 /app/ 目录下COPY . /todolist/app# 修改工作目录WORKDIR /todolist/appRUN npm config set registry https://registry.npm.taobao.org &amp;&amp; npm install# RUN [\"npm\", \"install\"]# 启动 node serverENTRYPOINT [\"npm\", \"run\", \"serve\"] cd 到静态页面的根目录执行: docker build -t static . 执行：docker run --name static -d -p 9000:8080 static启动静态容器 打开浏览器访问localhost:9000,可以看到页面成功渲染出列表页。 至此，mysql、node、vue 容器均已互通。代码需要完善的地方详见todolist docker-compose我们不可能每次部署一个应用，需要手动启动好几个服务。这个时候就需要使用docker-compose 关于命令就不介绍了，这里贴下链接docker-compose 命令 在根目录下新建docker-compose.yml配置文件 123456789101112131415161718192021222324252627282930313233version: '2'services: static: build: ./app/ container_name: static ports: - 7001:8080 depends_on: - nodejs - db nodejs: build: context: ./server/ dockerfile: sleep-dockerfile container_name: nodejs ports: - 4000:3000 environment: - IS_START_BY_COMPOSE=1 command: sh ./sleep.sh depends_on: - db db: image: mysql:5.6 container_name: db environment: MYSQL_ROOT_PASSWORD: \"123456\" command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 具体配置，详见上面贴的链接。下面我介绍下我所写的配置 version: docker-compose 的版本 services: 代表你用 docker-compose 启动的几个服务 build: 指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。 container_name: 指定容器名称。 ports: 相当于 docker run 启动容器的-p，&lt;主机 ip:容器 ip&gt;，这样主机通过这个端口去访问容器中的服务。 environment: 只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。简而言之，就是在容器内可以获取给的环境变量。 depends_on: 解决容器的依赖、启动先后的问题。（但是它有个问题就是只是等所依赖的服务开启启动，并不是等依赖的服务启动成功后在构建当前的服务。 command: 覆盖容器启动后默认执行的命令 接下来解释下上面用 compose 启动的服务 值得一提的是，mysql 的 Dockerfile 中做了创建数据库与表的操作。会涉及到关闭数据库密码登录功能。因为关闭之后，操作数据库就不需要输入密码了。等表建完之后在恢复密码。nodejs 中的 sleep.sh 脚本是因为 depends_on 这个依赖只是单纯的等待其他服务开始启动，并不是等待依赖的服务启动完成之后才开始构建自身的服务。这个时候 node 初始化会在 mysql 启动完成之前启动。这样的话，node 启动的时候连接 mysql 就会报错，导致 node 服务挂掉。所以引用了 sleep.sh，让 node 延迟一段时间启动。 最后在docker-compose文件所在的目录下执行docker-compose build 再执行：docker-compose up就可以启动 todolist 这个应用的所有服务了。","link":"/blog/2019/07/07/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AE%9E%E6%88%98%E7%AF%87/"},{"title":"前端必须知道的nginx知识","text":"前端开发者进阶之路不得不学 nginx。 本文内容涉及 nginx 命令 配置文件、配置解释 变量 日志 跨域 代理请求 location 拦截详解 gzip 防盗链 反向代理、正向代理 负载均衡 缓存 rewrite 正文命令 nginx -T 查看当前 nginx 最终的配置 nginx -t 检查配置文件是否有语法错误 nginx -s reload 向主进程发送信号，重新加载配置文件 nginx -s stop 快速关闭 nginx -s quit 等待工作进程处理完成后关闭 配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556user nginx; # 定义 Nginx 运行的用户worker_processes 1; # 设置工作进程的数量error_log /var/log/nginx/error.log warn; #nginx 错误日志pid /var/run/nginx.pid; # nginx.pid存放的是nginx的master进程的进程号# events模块中包含nginx中所有处理连接的设置events { #工作进程的最大连接数量 理论上每台nginx服务器的最大连接数为worker_processes*worker_connections worker_processes为我们再main中开启的进程数 worker_connections 1024;}# 提供http服务相关的一些配置参数http { # include 是个主模块指令，可以将配置文件拆分并引用，可以减少主配置文件的复杂度, 这里是加载一些文件类型 include /etc/nginx/mime.types; # default_type 属于HTTP核心模块指令，这里设定默认类型为二进制流，也就是当文件类型未定义时使用这种方式 default_type application/octet-stream; # 定义日志格式 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; # 定义本虚拟主机的访问日志 access_log /var/log/nginx/access.log main; sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改 成off sendfile on; tcp_nopush on; keepalive_timeout 65; #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 2; #压缩等级 limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用 server { listen 80; # 表示http监听的端口 server_name localhost; # 域名可以有多个，用空格隔开 当出现多个server监听的端口一样时，可通过server_name 做区分 # 有些指令可以支持正则表达式 location / { # 用于匹配URI，这里也可以用正则的方式匹配 ~ 表示大小写敏感 ~*表示大小写不敏感 root html; # 指定了静态文件的根目录 index index.html index.htm; } error_page 500 502 503 504 /50x.html; # 表示当在500 502 503 504 错误码的时候重定向到 /50x.html location = /50x.html { root html; } } include /etc/nginx/conf.d/*.conf; # 用于加载其他配置文件进来} 变量 字段 说明 $arg_PARAMETER 这个变量值为：GET 请求中变量名 PARAMETER 参数的值。 $args 这个变量等于 GET 请求中的参数。例如，foo=123&amp;bar=blahblah;这个变量只可以被修改 $binary_remote_addr 二进制码形式的客户端地址。 $body_bytes_sent 传送页面的字节数 $content_length 请求头中的 Content-length 字段。 $content_type 请求头中的 Content-Type 字段。 $cookie_COOKIE cookie COOKIE 的值。 $document_root 当前请求在 root 指令中指定的值。 $document_uri 与 $uri 相同。 $host 请求中的主机头(Host)字段，如果请求中的主机头不可用或者空，则为处理请求的 server 名称(处理请求的 server 的 server_name 指令的值)。值为小写，不包含端口。 $hostname 机器名使用 gethostname 系统调用的值 $http_HEADER HTTP请求头中的内容，HEADER 为 HTTP 请求中的内容转为小写，-变为_(破折号变为下划线)，例如：$http_user_agent(Uaer-Agent 的值), $http_referer…; $sent_http_HEADER HTTP响应头中的内容，HEADER为HTTP响应中的内容转为小写，-变为_(破折号变为下划线)， 例如：$sent_http_cache_control, $sent_http_content_type…; $is_args 如果$args 设置，值为”?”，否则为””。 $limit_rate 这个变量可以限制连接速率。 $nginx_version 当前运行的 nginx 版本号。 $query_string 与$args 相同。 $remote_addr 客户端的 IP 地址。 $remote_port 客户端的端口。 $remote_user 已经经过 Auth Basic Module 验证的用户名。 $request_filename 当前连接请求的文件路径，由 root 或 alias 指令与 URI 请求生成。 $request_body 这个变量（0.7.58+）包含请求的主要信息。在使用 proxy_pass 或 fastcgi_pass 指令的 location 中比较有意义。 $request_body_file 客户端请求主体信息的临时文件名。 $request_completion 如果请求成功，设为”OK”；如果请求未完成或者不是一系列请求中最后一部分则设为空。 $request_method 这个变量是客户端请求的动作，通常为 GET 或 POST。包括 0.8.20 及之前的版本中，这个变量总为 main request 中的动作，如果当前请求是一个子请求，并不使用这个当前请求的动作。 $request_uri 这个变量等于包含一些客户端请求参数的原始 URI，它无法修改，请查看$uri 更改或重写 URI。 $scheme 所用的协议，比如http或者是https，比如rewrite ^(.+)$ $scheme://example.com$1 redirect; $server_addr 服务器地址，在完成一次系统调用后可以确定这个值，如果要绕开系统调用，则必须在 listen 中指定地址并且使用 bind 参数。 $server_name 服务器名称。 $server_port 请求到达服务器的端口号。 $server_protocol 请求使用的协议，通常是 HTTP/1.0 或 HTTP/1.1。 日志error_log表示错误日志。error_log /var/log/nginx/error.log warn; 。错误日志记录了访问出错的信息。有利于我们排查错误。 access_log表示访问日志。需要指定日志格式 log_format。通过访问日志我们可以得到用户的 IP 地址、浏览器的信息，请求的处理时间等信息 log_format日志格式可以结合上面的变量，来指定访问日志的输出格式。 如： 123456789log_format main '$host $document_uri $server_addr $remote_addr $remote_port';server { listen 5002; access_log /usr/local/etc/nginx/servers/access.log main; location / { root /usr/local/etc/nginx/servers; index index.html; }} 定义了个日志格式 main 然后在将access_log绑定日志main 输出： 1localhost /index.html 127.0.0.1 127.0.0.1 61517 可以看到，access_log 按照我的 main 日志格式输出了。 跨域相信作为前端开发者，你肯定知道 CORS。 Access-Control-Allow-Origin | *;其中，origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。 Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header 在跨域访问时，XMLHttpRequest 对象的 getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。 Access-Control-Max-AgeAccess-Control-Max-Age 头指定了 preflight 请求的结果能够被缓存多久;Access-Control-Max-Age: 86400 Access-Control-Allow-Credentials 指定了当浏览器的 credentials 设置为 true 时是否允许浏览器读取 response 的内容。当用在对 preflight 预检测请求的响应中时，它指定了实际的请求是否可以使用 credentials。请注意：简单 GET 请求不会被预检；如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页 话不多少，下面就直接贴代码： 1234567// index.jsimport axios from 'axios';axios.get('http://127.0.0.1:5556/api/abc').then(res =&gt; { console.log(res, 'res'); document.write(res);}); 1234567server { listen 5556; location /api { proxy_pass http://localhost:5000; add_header Access-Control-Allow-Origin *; }} 将 5556 端口的请求路径 /api 开头的 转发到 5000 端口的 node 服务上。添加上Access-Control-Allow-Origin *就可解决跨域问题。 代理请求代理请求可以看下上面的跨域。把 5556 端口的请求转发到 5000 端口的服务上。 location 拦截详解修饰符 =: 精确匹配路径 ~: 表示用该符号后面的正则去匹配路径，区分大小写 ~*: 表示用该符号后面的正则去匹配路径，不区分大小写 ^~: 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找。 12345678910111213141516171819location = / { [ configuration A ]}location / { [ configuration B ]}location /api/ { [ configuration C ]}location ^~ /static/ { [ configuration D ]}location ~* \\.(gif|jpg|jpeg)$ { [ configuration E ]} 请求/精准匹配 A，不再往下查找。 请求/index.html 匹配 B。首先查找匹配的前缀字符，找到最长匹配是配置 B，接着又按照顺序查找匹配的正则。结果没有找到，因此使用先前标记的最长匹配，即配置 B。 请求/api/list 匹配 C。首先找到最长匹配 C，由于后面没有匹配的正则，所以使用最长匹配 C。 请求/user/1.jpg 匹配 E。首先进行前缀字符的查找，找到最长匹配项 C，继续进行正则查找，找到匹配项 E。因此使用 E。 请求/static/img.jpg 匹配 D。首先进行前缀字符的查找，找到最长匹配 D。但是，特殊的是它使用了^~修饰符，不再进行接下来的正则的匹配查找，因此使用 D。这里，如果没有前面的修饰符，其实最终的匹配是 E。 请求/router/pageA 匹配 B。因为 B 表示任何以/开头的 URL 都匹配。在上面的配置中，只有 B 能满足，所以匹配 B。 gzip配置说明1234567891011121314151617# gzip 默认off 默认关闭gzipgzip on;# gzip_min_length 默认0# 作用域: http, server, location# 设置允许压缩的页面最小字节数，页面字节数从header头中的Content-Length中进行获取。# 默认值是0，不管页面多大都压缩。# 建议设置成大于1k的字节数，小于1k可能会越压越大。 即: gzip_min_length 1024gzip_min_length 1k;# gzip_comp_level 默认 1 范围 1 ~ 9# 作用域: http, server, location# gzip压缩比，1 压缩比最小处理速度最快，9 压缩比最大但处理最慢（传输快但比较消耗cpu）。gzip_comp_level 6;# 默认值: gzip_types text/html# 作用域: http, server, location# 匹配MIME类型进行压缩，（无论是否指定）\"text/html\"类型总是会被压缩的。# 注意：如果作为http server来使用，主配置文件中要包含文件类型配置文件gzip_types text/plain application/x-javascript text/css application/xml application/javascript application/json; 代码演示12345678server { listen 9002; #gzip on; location / { root /usr/local/etc/nginx/servers/; index gzip.html; }} 我们先记录下未开启 gzip 时加载的文件大小 size 显示的是 1.3kb 然后我们将 gzip 注释去掉的结果如下 可以看到只有 300B 了，当然你还可以根据其他配置，比如来控制压缩等级来控制输出的大小。我们前端项目打包的时候可以开启 gzip，这样 nginx 就不用在服务器上进行 gzip 压缩了。 防盗链1234567location ~ .*\\.(jpg|png|gif)$ { valid_referers none blocked 47.104.184.134; if ($invalid_referer) { return 403; } root /data/images;} valid_referers none | blocked | server_names | string ….;none 检测 Referer 头域不存在的请求blocked 检测 Referer 头域的值被防火墙或者代理服务器删除或伪装的情况。这种情况下，该头域的值不以“http://”或者“https：//”开头server_names 设置一个或多个 URL,检测 Referer 头域的值是否是这些 URL 中的某个。从 nginx 0.5.33 以后支持使用通配符“*”。 valid_referers 用于支持访问该资源的 referers $invalid_referer 这个变量为 true 表示不符合上面定义的规则。就 return 403 反向代理、正向代理正向代理123location / { proxy_pass http://$http_host$request_uri;} 正向代理你可以理解为代理客户端，比如 VPN。因为国内无法访问国外的网站，所以通过将请求转发到 VPN 服务器，VPN 将你的请求原封不动的转发到国外网址。正向代理，客户端知道服务端，服务端不知道客户端。 反向代理比如说下面将会讲到的负载均衡。所有请求统一走到一个 nginx 服务上，由这个 nginx 服务讲请求分配到多台服务器上。 负载均衡代码演示12345.├── 9004.html├── 9005.html├── 9006.html└── upstream.conf 12345678910111213141516171819202122232425262728293031323334server { listen 9004; location / { root /usr/local/etc/nginx/servers/; index 9004.html; }}server { listen 9005; location / { root /usr/local/etc/nginx/servers/; index 9005.html; }}server { listen 9006; location / { root /usr/local/etc/nginx/servers/; index 9006.html; }}upstream atie { server localhost:9004; server localhost:9005; server localhost:9006;}server { listen 9003; location / { proxy_pass http://atie; }} 通过上面代码可以看到我通过访问 9003 端口，均衡到其他端口。 打开浏览器访问 localhost:9003 可以看到页面会分别加载 9004 ~ 9006.html 页面 配置介绍 状态 描述 down 不参与负载均衡 backup 备份的服务器 max_fails 允许请求失败的次数 fail_timeout 经过 max_fails 失败后，服务暂停的时间 max_conns 限制最大的接收的连接数 weight 权重比 12345upstream atie { server localhost:9004 down; # 这里如果加了down 表示负载均衡的时候就不会转到这个服务 server localhost:9005 backup; # 表示备份 只有当服务挂了，才会走到这个备份服务上 server localhost:9006 max_fails=1 fail_timeout=10s; # 超过最大次数后，在fail_timeout时间内，新的请求将不会分配给这台机器。} 12345upstream atie { server localhost:9004 weight=1; server localhost:9005 weight=2; server localhost:9006 weight=3;} 当你访问 6 次时，一次走到 9004 2 次走到 9005 3 次走到 9006 缓存通过添加缓存请求头设置过期时间等 123location ~ .*\\.(gif|jpg|png|css|js)(.*) { expires 90d; # 设置有效90天} rewriterewrite 功能就是，使用 nginx 提供的全局变量或自己设置的变量，结合正则表达式和标志位实现 url 重写以及重定向。rewrite 只能放在 server{},location{},if{}中，并且只能对域名后边的除去传递的参数外的字符串起作用 1234567location / { rewrite /rewrite/(.*) http://www.$1.com; return 200 \"ok\";}# 在浏览器中输入 127.0.0.1:8080/rewrite/google# 则临时重定向到 www.google.com# 后面的 return 指令将没有机会执行了","link":"/blog/2019/09/01/%E5%89%8D%E7%AB%AF%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84nginx%E7%9F%A5%E8%AF%86/"},{"title":"手写Promise","text":"😆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168class TPromise { static PENDING = 'PENDING'; static RESOLVED = 'RESOLVED'; static REJECTED = 'REJECTED'; constructor(handler) { // 下面队列用于存储方法 this.resolveQueues = []; this.rejectQueues = []; this.finallyQueues = []; this.state = TPromise.PENDING; handler(this._resolve.bind(this), this._reject.bind(this)); } _resolve(val) { // 因为promise是微任务，这里使用MutationObserver来模拟微任务 let observer = new MutationObserver(() =&gt; { // 一旦状态机修改过状态，那么就无法再改变状态 if (this.state !== TPromise.PENDING) return; this.state = TPromise.RESOLVED; this.value = val; let handler; while ((handler = this.resolveQueues.shift())) { handler(this.value); } while ((handler = this.finallyQueues.shift())) { handler(); } }); observer.observe(document.body, { attributes: true }); document.body.setAttribute('_promise', Date.now()); } _reject(val) { // 因为promise是微任务，这里使用MutationObserver来模拟微任务 let observer = new MutationObserver(() =&gt; { // 一旦状态机修改过状态，那么就无法再改变状态 if (this.state !== TPromise.PENDING) return; this.state = TPromise.REJECTED; this.value = val; let handler; while ((handler = this.rejectQueues.shift())) { handler(this.value); } while ((handler = this.finallyQueues.shift())) { handler(); } }); observer.observe(document.body, { attributes: true }); document.body.setAttribute('_promise', Date.now()); } then(resolveHandler, rejectHandler) { // 每一个then都是返回一个新的promise return new TPromise((resolve, reject) =&gt; { if (typeof resolveHandler === 'function') { const newResolveHandler = val =&gt; { let result = resolveHandler(val); if (result instanceof TPromise) { // 如果返回的结果是个promise实例的话，调用下面方法 result.then(resolve, reject); } else { resolve(result); } }; // promise每次resolve的时候，都会去执行resolveQueues队列中的所有方法 this.resolveQueues.push(newResolveHandler); } else { // promise每次resolve的时候，都会去执行resolveQueues队列中的所有方法 this.resolveQueues.push(resolve); } if (typeof rejectHandler === 'function') { const newRejectHandler = val =&gt; { let result = rejectHandler(val); if (result instanceof TPromise) { result.then(resolve, reject); } else { resolve(result); } }; this.rejectQueues.push(newRejectHandler); } else { this.rejectQueues.push(reject); } }); } catch(rejectHandler) { // catch 实质上是then的一种简写 return this.then(undefined, rejectHandler); } finally(finallyHandler) { return new TPromise((resolve, reject) =&gt; { if (typeof finallyHandler === 'function') { const newFinallyHandler = () =&gt; { const result = finallyHandler(); if (result instanceof TPromise) { result.finally(() =&gt; { if (this.state === TPromise.RESOLVED) resolve(this.value); else if (this.state === TPromise.REJECTED) reject(this.value); }); } else { if (this.state === TPromise.RESOLVED) resolve(this.value); else if (this.state === TPromise.REJECTED) reject(this.value); } }; this.finallyQueues.push(newFinallyHandler); } }); } // all 只有当所有promise都成功返回时，才resolve static all(arr) { let i = 0; const resArr = []; return new TPromise((resolve, reject) =&gt; { arr.forEach((it, index) =&gt; { it.then(res =&gt; { i++; resArr[index] = res; if (i &gt;= arr.length) { resolve(resArr); } }).catch(err =&gt; { reject(err); }); }); }); } // race 返回第一个有结果的promise static race(arr) { return new TPromise((resolve, reject) =&gt; { arr.forEach((it, index) =&gt; { it.then(res =&gt; { resolve(res); }).catch(err =&gt; { reject(err); }); }); }); } static resolve(val) { return new TPromise((resolve, reject) =&gt; { if (val instanceof TPromise) { val.then(resolve, reject); } else { resolve(val); } }); } // 注意reject 会原封不动的将参数返回 static reject(val) { return new TPromise((resolve, reject) =&gt; { reject(val); }); }}","link":"/blog/2019/09/12/%E6%89%8B%E5%86%99Promise/"},{"title":"命令行翻译插件","text":"@zhouatie/fanyi 说明平时开发的时候，遇到不会的单词，总要打开 一个翻译软件，或者浏览器翻译插件去查。所以就想开发一个命令行翻译插件，并发布到 npm 库上供大家使用。如果有帮助到你的话，可以给我仓库来个 star😆 安装npm i @zhouatie/fanyi -g 使用翻译英文12345678# 翻译单词apple的意思fanyi apple----------------------英 [ˈæpl] 美 [ˈæpl]n. 苹果，苹果树，苹果似的东西；[美俚]炸弹，手榴弹，（棒球的）球；[美俚]人，家伙。 123456# 翻译句子fanyi my name is bob---------------我叫鲍勃 翻译中文1234567fanyi 苹果----------苹果 [píng guǒ][园艺] apple 12345fanyi 我是前端工程师-----------I'm a front end engineer TODO 支持句子翻译 加入 commonader 支持选择多个翻译平台","link":"/blog/2019/11/25/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6/"},{"title":"docker从零搭建jenkins","text":"前言写这篇文章的灵感来源于最近公司的 jenkins 部署老是失败，各种原因。在项目非常赶的情况下，我每天还要抽半天时间去排查 jenkins 上的问题。所以决定在我们前端服务器上搭建个 jenkins 给测试部署。并部署到前端服务器上。文章是边操作边写出来的，踩遍了坑。不知道大家会不会也遇到这些问题。反正我都把解决步骤写在里面了。 本文主要内容是介绍 jenkins 的搭建与使用。至于是安装在服务器上还是本文通过 docker 安装 jenkins 不是很重要，默认读者会使用 docker。如果不是很了解docker可看我的docker 从入门到实战博客 安装 jenkinsdocker pull docker.io/jenkins/jenkins:latest 安装成功后使用docker images查看镜像 123github docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEjenkins/jenkins latest 59f8784e08ee 2 days ago 619MB 在启动 Jenkins 前，需要先创建一个 Jenkins 的配置目录，并且挂载到 docker 里的 Jenkins 目录下 新建一个文件夹如我的/Users/zhouatie/Desktop/github/front-end/practise-jenkins 并给该文件夹授权sudo chown -R 1000 /Users/zhouatie/Desktop/github/front-end/practise-jenkins 这里有个很神奇的点就是网上都说要授权，所以我授权了，但是还是提示Can not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions。后来我新建了个文件夹不做授权处理就可以了。可查阅stackoverflow 这里面一位朋友就是遇到相同的问题 授权了也没用。 执行以下命令构建容器 1docker run -itd -p 8080:8080 -p 50000:50000 --name jenkins -v /Users/zhouatie/Desktop/github/front-end/practise-jenkins:/var/jenkins_home docker.io/jenkins/jenkins:latest 执行docker ps查看后台启动的容器情况 123➜ front-end git:(master) ✗ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3385ad0e42fe jenkins/jenkins:latest \"/sbin/tini -- /usr/…\" 5 minutes ago Up 5 minutes 0.0.0.0:8080-&gt;8080/tcp, 0.0.0.0:50000-&gt;50000/tcp jenkins 可以看到 jenkins 容器已经启动成功了。这个时候访问下页面吧。浏览器输入 localhost:8080 可以看到如下界面 这个时候我们就可以到刚才管理数据卷的文件夹里找了(我本地是/Users/zhouatie/Desktop/github/front-end/practise-jenkins/secrets/initialAdminPassword)，cat下这个文件可以看到输出28023d3751214bd6aadc0dd83c168325，把这个密码复制到管理员密码输入框中并点击继续。 loading 转了半天，有种不详的预感。结果不出意外显示 jenkins 离线。所以我又开始上网搜新版本 jenkins 安装时显示离线问题 解决步骤 浏览器输入http://localhost:8080/pluginManager/advanced 划到最下面可以看到 将截图中的地址替换为http://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/current/update-center.json这个代理服务器 再刷新下http://localhost:8080页面如下 点击安装推荐的插件 结果不出意外如下图 然后我又开始google了。找到了这个安装 jenkins 时出现 No such plugin: cloudbees-folder 的解决办法 结果按照前几个步骤失败，作者建议重启，好吧，重启就重启，执行下 docker restart jenkins 终于又成功进入下载页了。 安装真的超级慢，心急如焚，不知道是不是 docker 的原因。因为文章是直接边操作边写的。在想要不要直接跨过这个安装界面，直接打开自己跑在前端服务器上的 jenkins 了开始介绍了 还没等他提示完全失败，这个时候我就又开始google了。实在没辙了，这的太难了。所以我重启了个jenkins容器后，选择自选插件。然后什么也不选，进了页面后，可以在如下截图地方下载，我是将上面推荐的全部勾选后进行下载，结果还很快。 安装完插件后重启下，可以看到界面如下 构建 点击右上角的新建任务 选择第一个自由风格模式 确点后进入如下页面，并点击配置 因为部分插件装失败了，我就以在装成功的 jenkins 配置界面截图为例 参数化构建：这里主要提下参数化构建，这里对应的值都可以在下面【构建】执行 shell 中获取到部署的时候用户手动选择或者填入的参数。 源码管理：主要是让 jenkins 从你的 git 仓库中拉代码，credentials需要选择有该仓库权限的账号，可以手动试下 构建触发器：意思就是触发条件，比如git上的webhook，就可以触发jenkins部署。具体可查阅google 构建：这个是重点，这里可以执行你的脚本，比如你是一个 vue 项目，可以根据上面配置的参数化配置，获取是否需要安装依赖等。可看我图中shell脚本，非常好理解。","link":"/blog/2020/04/02/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAjenkins/"},{"title":"源码实现系列之Vuex","text":"这个月会实现一下Vue, Vuex, vue-router。我会以倒推的模式边开发边写文章。话不多说开始跟着我一起撸。 回忆下我们平时代码里用到vuex必定会有的两行代码 123Vue.use(Vuex);store = new Vuex.Store({}); 所以vuex需要导出两个方法，一个提供use的install方法，一个就是Store 123456// vuex.jsexport default { install, Store}; 诸如vuex、vue-router等都是使用Vue.mixin,往每个组件上挂载beforeCreate生命周期来初始化。 上代码 123456789101112const install = _Vue =&gt; { Vue = _Vue; Vue.mixin({ beforeCreate() { if (this.$options.store) { this.$store = this.$options.store; } else { this.$store = this.$parent &amp;&amp; this.$parent.$store; } } });}; Vue的use方法我就不解释了，感兴趣的可以去看下vue源码，他是调用use参数的install方法，并传入Vue构造函数。那么上述为什么会判断this.$options.store和读取$parent.$store呢？ 这个时候请回忆下我们new Vue的都会传入store,所以当this.$options.store获取不到，代表他不是根节点（当然子组件也可以加store,这里只是常规分析）。this.$store = this.$parent &amp;&amp; this.$parent.$store;，那么他很有可能就是子组件，就会向上层获取，上层肯定会有。就这样一层层往下传递。 install讲完了，接下来就讲我们的重头戏，Store; 明天继续明天继续明天继续明天继续明天继续明天继续敬请期待敬请期待敬请期待敬请期待","link":"/blog/2020/04/02/%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97%E4%B9%8BVuex/"}],"tags":[{"name":"plugin","slug":"plugin","link":"/blog/tags/plugin/"},{"name":"image-preview","slug":"image-preview","link":"/blog/tags/image-preview/"},{"name":"node","slug":"node","link":"/blog/tags/node/"},{"name":"formdata","slug":"formdata","link":"/blog/tags/formdata/"},{"name":"react","slug":"react","link":"/blog/tags/react/"},{"name":"socket.io","slug":"socket-io","link":"/blog/tags/socket-io/"},{"name":"js","slug":"js","link":"/blog/tags/js/"},{"name":"webpack","slug":"webpack","link":"/blog/tags/webpack/"},{"name":"docker","slug":"docker","link":"/blog/tags/docker/"},{"name":"vue","slug":"vue","link":"/blog/tags/vue/"},{"name":"nginx","slug":"nginx","link":"/blog/tags/nginx/"},{"name":"promise","slug":"promise","link":"/blog/tags/promise/"},{"name":"fanyi","slug":"fanyi","link":"/blog/tags/fanyi/"},{"name":"http","slug":"http","link":"/blog/tags/http/"},{"name":"cache","slug":"cache","link":"/blog/tags/cache/"},{"name":"jenkins","slug":"jenkins","link":"/blog/tags/jenkins/"},{"name":"vuex","slug":"vuex","link":"/blog/tags/vuex/"}],"categories":[{"name":"前端","slug":"前端","link":"/blog/categories/%E5%89%8D%E7%AB%AF/"},{"name":"工具","slug":"工具","link":"/blog/categories/%E5%B7%A5%E5%85%B7/"},{"name":"持续集成","slug":"持续集成","link":"/blog/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"}]}